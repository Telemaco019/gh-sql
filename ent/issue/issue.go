// Code generated by ent, DO NOT EDIT.

package issue

import (
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/gnoverse/gh-sql/pkg/model"
)

const (
	// Label holds the string label denoting the issue type in the database.
	Label = "issue"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldNodeID holds the string denoting the node_id field in the database.
	FieldNodeID = "node_id"
	// FieldURL holds the string denoting the url field in the database.
	FieldURL = "url"
	// FieldRepositoryURL holds the string denoting the repository_url field in the database.
	FieldRepositoryURL = "repository_url"
	// FieldLabelsURL holds the string denoting the labels_url field in the database.
	FieldLabelsURL = "labels_url"
	// FieldCommentsURL holds the string denoting the comments_url field in the database.
	FieldCommentsURL = "comments_url"
	// FieldEventsURL holds the string denoting the events_url field in the database.
	FieldEventsURL = "events_url"
	// FieldHTMLURL holds the string denoting the html_url field in the database.
	FieldHTMLURL = "html_url"
	// FieldNumber holds the string denoting the number field in the database.
	FieldNumber = "number"
	// FieldState holds the string denoting the state field in the database.
	FieldState = "state"
	// FieldStateReason holds the string denoting the state_reason field in the database.
	FieldStateReason = "state_reason"
	// FieldTitle holds the string denoting the title field in the database.
	FieldTitle = "title"
	// FieldBody holds the string denoting the body field in the database.
	FieldBody = "body"
	// FieldLocked holds the string denoting the locked field in the database.
	FieldLocked = "locked"
	// FieldActiveLockReason holds the string denoting the active_lock_reason field in the database.
	FieldActiveLockReason = "active_lock_reason"
	// FieldCommentsCount holds the string denoting the comments_count field in the database.
	FieldCommentsCount = "comments_count"
	// FieldClosedAt holds the string denoting the closed_at field in the database.
	FieldClosedAt = "closed_at"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldDraft holds the string denoting the draft field in the database.
	FieldDraft = "draft"
	// FieldAuthorAssociation holds the string denoting the author_association field in the database.
	FieldAuthorAssociation = "author_association"
	// FieldReactions holds the string denoting the reactions field in the database.
	FieldReactions = "reactions"
	// EdgeRepository holds the string denoting the repository edge name in mutations.
	EdgeRepository = "repository"
	// EdgeUser holds the string denoting the user edge name in mutations.
	EdgeUser = "user"
	// EdgeClosedBy holds the string denoting the closed_by edge name in mutations.
	EdgeClosedBy = "closed_by"
	// EdgeAssignees holds the string denoting the assignees edge name in mutations.
	EdgeAssignees = "assignees"
	// EdgeComments holds the string denoting the comments edge name in mutations.
	EdgeComments = "comments"
	// EdgeTimeline holds the string denoting the timeline edge name in mutations.
	EdgeTimeline = "timeline"
	// EdgePullRequest holds the string denoting the pull_request edge name in mutations.
	EdgePullRequest = "pull_request"
	// Table holds the table name of the issue in the database.
	Table = "issues"
	// RepositoryTable is the table that holds the repository relation/edge.
	RepositoryTable = "issues"
	// RepositoryInverseTable is the table name for the Repository entity.
	// It exists in this package in order to avoid circular dependency with the "repository" package.
	RepositoryInverseTable = "repositories"
	// RepositoryColumn is the table column denoting the repository relation/edge.
	RepositoryColumn = "repository_issues"
	// UserTable is the table that holds the user relation/edge.
	UserTable = "issues"
	// UserInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	UserInverseTable = "users"
	// UserColumn is the table column denoting the user relation/edge.
	UserColumn = "user_issues_created"
	// ClosedByTable is the table that holds the closed_by relation/edge.
	ClosedByTable = "issues"
	// ClosedByInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	ClosedByInverseTable = "users"
	// ClosedByColumn is the table column denoting the closed_by relation/edge.
	ClosedByColumn = "user_issues_closed"
	// AssigneesTable is the table that holds the assignees relation/edge. The primary key declared below.
	AssigneesTable = "issue_assignees"
	// AssigneesInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	AssigneesInverseTable = "users"
	// CommentsTable is the table that holds the comments relation/edge.
	CommentsTable = "issue_comments"
	// CommentsInverseTable is the table name for the IssueComment entity.
	// It exists in this package in order to avoid circular dependency with the "issuecomment" package.
	CommentsInverseTable = "issue_comments"
	// CommentsColumn is the table column denoting the comments relation/edge.
	CommentsColumn = "issue_comments"
	// TimelineTable is the table that holds the timeline relation/edge.
	TimelineTable = "timeline_events"
	// TimelineInverseTable is the table name for the TimelineEvent entity.
	// It exists in this package in order to avoid circular dependency with the "timelineevent" package.
	TimelineInverseTable = "timeline_events"
	// TimelineColumn is the table column denoting the timeline relation/edge.
	TimelineColumn = "issue_timeline"
	// PullRequestTable is the table that holds the pull_request relation/edge.
	PullRequestTable = "pull_requests"
	// PullRequestInverseTable is the table name for the PullRequest entity.
	// It exists in this package in order to avoid circular dependency with the "pullrequest" package.
	PullRequestInverseTable = "pull_requests"
	// PullRequestColumn is the table column denoting the pull_request relation/edge.
	PullRequestColumn = "issue_pull_request"
)

// Columns holds all SQL columns for issue fields.
var Columns = []string{
	FieldID,
	FieldNodeID,
	FieldURL,
	FieldRepositoryURL,
	FieldLabelsURL,
	FieldCommentsURL,
	FieldEventsURL,
	FieldHTMLURL,
	FieldNumber,
	FieldState,
	FieldStateReason,
	FieldTitle,
	FieldBody,
	FieldLocked,
	FieldActiveLockReason,
	FieldCommentsCount,
	FieldClosedAt,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldDraft,
	FieldAuthorAssociation,
	FieldReactions,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "issues"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"repository_issues",
	"user_issues_created",
	"user_issues_closed",
}

var (
	// AssigneesPrimaryKey and AssigneesColumn2 are the table columns denoting the
	// primary key for the assignees relation (M2M).
	AssigneesPrimaryKey = []string{"issue_id", "user_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

// StateReasonValidator is a validator for the "state_reason" field enum values. It is called by the builders before save.
func StateReasonValidator(sr model.StateReason) error {
	switch sr {
	case "completed", "reopened", "not_planned":
		return nil
	default:
		return fmt.Errorf("issue: invalid enum value for state_reason field: %q", sr)
	}
}

// AuthorAssociationValidator is a validator for the "author_association" field enum values. It is called by the builders before save.
func AuthorAssociationValidator(aa model.AuthorAssociation) error {
	switch aa {
	case "COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "OWNER", "NONE":
		return nil
	default:
		return fmt.Errorf("issue: invalid enum value for author_association field: %q", aa)
	}
}

// OrderOption defines the ordering options for the Issue queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByNodeID orders the results by the node_id field.
func ByNodeID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNodeID, opts...).ToFunc()
}

// ByURL orders the results by the url field.
func ByURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldURL, opts...).ToFunc()
}

// ByRepositoryURL orders the results by the repository_url field.
func ByRepositoryURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldRepositoryURL, opts...).ToFunc()
}

// ByLabelsURL orders the results by the labels_url field.
func ByLabelsURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLabelsURL, opts...).ToFunc()
}

// ByCommentsURL orders the results by the comments_url field.
func ByCommentsURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCommentsURL, opts...).ToFunc()
}

// ByEventsURL orders the results by the events_url field.
func ByEventsURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEventsURL, opts...).ToFunc()
}

// ByHTMLURL orders the results by the html_url field.
func ByHTMLURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldHTMLURL, opts...).ToFunc()
}

// ByNumber orders the results by the number field.
func ByNumber(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNumber, opts...).ToFunc()
}

// ByState orders the results by the state field.
func ByState(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldState, opts...).ToFunc()
}

// ByStateReason orders the results by the state_reason field.
func ByStateReason(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStateReason, opts...).ToFunc()
}

// ByTitle orders the results by the title field.
func ByTitle(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTitle, opts...).ToFunc()
}

// ByBody orders the results by the body field.
func ByBody(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBody, opts...).ToFunc()
}

// ByLocked orders the results by the locked field.
func ByLocked(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLocked, opts...).ToFunc()
}

// ByActiveLockReason orders the results by the active_lock_reason field.
func ByActiveLockReason(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldActiveLockReason, opts...).ToFunc()
}

// ByCommentsCountField orders the results by the comments_count field.
func ByCommentsCountField(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCommentsCount, opts...).ToFunc()
}

// ByClosedAt orders the results by the closed_at field.
func ByClosedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldClosedAt, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByDraft orders the results by the draft field.
func ByDraft(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDraft, opts...).ToFunc()
}

// ByAuthorAssociation orders the results by the author_association field.
func ByAuthorAssociation(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAuthorAssociation, opts...).ToFunc()
}

// ByRepositoryField orders the results by repository field.
func ByRepositoryField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newRepositoryStep(), sql.OrderByField(field, opts...))
	}
}

// ByUserField orders the results by user field.
func ByUserField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUserStep(), sql.OrderByField(field, opts...))
	}
}

// ByClosedByField orders the results by closed_by field.
func ByClosedByField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newClosedByStep(), sql.OrderByField(field, opts...))
	}
}

// ByAssigneesCount orders the results by assignees count.
func ByAssigneesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAssigneesStep(), opts...)
	}
}

// ByAssignees orders the results by assignees terms.
func ByAssignees(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAssigneesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCommentsCount orders the results by comments count.
func ByCommentsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newCommentsStep(), opts...)
	}
}

// ByComments orders the results by comments terms.
func ByComments(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCommentsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTimelineCount orders the results by timeline count.
func ByTimelineCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTimelineStep(), opts...)
	}
}

// ByTimeline orders the results by timeline terms.
func ByTimeline(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTimelineStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByPullRequestField orders the results by pull_request field.
func ByPullRequestField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPullRequestStep(), sql.OrderByField(field, opts...))
	}
}
func newRepositoryStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(RepositoryInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, RepositoryTable, RepositoryColumn),
	)
}
func newUserStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UserInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
	)
}
func newClosedByStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ClosedByInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, ClosedByTable, ClosedByColumn),
	)
}
func newAssigneesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AssigneesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, AssigneesTable, AssigneesPrimaryKey...),
	)
}
func newCommentsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CommentsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, CommentsTable, CommentsColumn),
	)
}
func newTimelineStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TimelineInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, TimelineTable, TimelineColumn),
	)
}
func newPullRequestStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PullRequestInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, PullRequestTable, PullRequestColumn),
	)
}
