// Code generated by ent, DO NOT EDIT.

package pullrequest

import (
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/gnolang/gh-sql/pkg/model"
)

const (
	// Label holds the string label denoting the pullrequest type in the database.
	Label = "pull_request"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldURL holds the string denoting the url field in the database.
	FieldURL = "url"
	// FieldNodeID holds the string denoting the node_id field in the database.
	FieldNodeID = "node_id"
	// FieldHTMLURL holds the string denoting the html_url field in the database.
	FieldHTMLURL = "html_url"
	// FieldDiffURL holds the string denoting the diff_url field in the database.
	FieldDiffURL = "diff_url"
	// FieldPatchURL holds the string denoting the patch_url field in the database.
	FieldPatchURL = "patch_url"
	// FieldIssueURL holds the string denoting the issue_url field in the database.
	FieldIssueURL = "issue_url"
	// FieldCommitsURL holds the string denoting the commits_url field in the database.
	FieldCommitsURL = "commits_url"
	// FieldReviewCommentsURL holds the string denoting the review_comments_url field in the database.
	FieldReviewCommentsURL = "review_comments_url"
	// FieldReviewCommentURL holds the string denoting the review_comment_url field in the database.
	FieldReviewCommentURL = "review_comment_url"
	// FieldCommentsURL holds the string denoting the comments_url field in the database.
	FieldCommentsURL = "comments_url"
	// FieldStatusesURL holds the string denoting the statuses_url field in the database.
	FieldStatusesURL = "statuses_url"
	// FieldNumber holds the string denoting the number field in the database.
	FieldNumber = "number"
	// FieldState holds the string denoting the state field in the database.
	FieldState = "state"
	// FieldLocked holds the string denoting the locked field in the database.
	FieldLocked = "locked"
	// FieldTitle holds the string denoting the title field in the database.
	FieldTitle = "title"
	// FieldBody holds the string denoting the body field in the database.
	FieldBody = "body"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldClosedAt holds the string denoting the closed_at field in the database.
	FieldClosedAt = "closed_at"
	// FieldMergedAt holds the string denoting the merged_at field in the database.
	FieldMergedAt = "merged_at"
	// FieldMergeCommitSha holds the string denoting the merge_commit_sha field in the database.
	FieldMergeCommitSha = "merge_commit_sha"
	// FieldHead holds the string denoting the head field in the database.
	FieldHead = "head"
	// FieldBase holds the string denoting the base field in the database.
	FieldBase = "base"
	// FieldDraft holds the string denoting the draft field in the database.
	FieldDraft = "draft"
	// FieldAuthorAssociation holds the string denoting the author_association field in the database.
	FieldAuthorAssociation = "author_association"
	// EdgeRepository holds the string denoting the repository edge name in mutations.
	EdgeRepository = "repository"
	// EdgeIssue holds the string denoting the issue edge name in mutations.
	EdgeIssue = "issue"
	// EdgeUser holds the string denoting the user edge name in mutations.
	EdgeUser = "user"
	// EdgeMergedBy holds the string denoting the merged_by edge name in mutations.
	EdgeMergedBy = "merged_by"
	// EdgeAssignees holds the string denoting the assignees edge name in mutations.
	EdgeAssignees = "assignees"
	// EdgeRequestedReviewers holds the string denoting the requested_reviewers edge name in mutations.
	EdgeRequestedReviewers = "requested_reviewers"
	// Table holds the table name of the pullrequest in the database.
	Table = "pull_requests"
	// RepositoryTable is the table that holds the repository relation/edge.
	RepositoryTable = "pull_requests"
	// RepositoryInverseTable is the table name for the Repository entity.
	// It exists in this package in order to avoid circular dependency with the "repository" package.
	RepositoryInverseTable = "repositories"
	// RepositoryColumn is the table column denoting the repository relation/edge.
	RepositoryColumn = "repository_pull_requests"
	// IssueTable is the table that holds the issue relation/edge.
	IssueTable = "pull_requests"
	// IssueInverseTable is the table name for the Issue entity.
	// It exists in this package in order to avoid circular dependency with the "issue" package.
	IssueInverseTable = "issues"
	// IssueColumn is the table column denoting the issue relation/edge.
	IssueColumn = "issue_pull_request"
	// UserTable is the table that holds the user relation/edge.
	UserTable = "pull_requests"
	// UserInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	UserInverseTable = "users"
	// UserColumn is the table column denoting the user relation/edge.
	UserColumn = "user_prs_created"
	// MergedByTable is the table that holds the merged_by relation/edge.
	MergedByTable = "pull_requests"
	// MergedByInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	MergedByInverseTable = "users"
	// MergedByColumn is the table column denoting the merged_by relation/edge.
	MergedByColumn = "user_prs_merged"
	// AssigneesTable is the table that holds the assignees relation/edge. The primary key declared below.
	AssigneesTable = "pull_request_assignees"
	// AssigneesInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	AssigneesInverseTable = "users"
	// RequestedReviewersTable is the table that holds the requested_reviewers relation/edge. The primary key declared below.
	RequestedReviewersTable = "pull_request_requested_reviewers"
	// RequestedReviewersInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	RequestedReviewersInverseTable = "users"
)

// Columns holds all SQL columns for pullrequest fields.
var Columns = []string{
	FieldID,
	FieldURL,
	FieldNodeID,
	FieldHTMLURL,
	FieldDiffURL,
	FieldPatchURL,
	FieldIssueURL,
	FieldCommitsURL,
	FieldReviewCommentsURL,
	FieldReviewCommentURL,
	FieldCommentsURL,
	FieldStatusesURL,
	FieldNumber,
	FieldState,
	FieldLocked,
	FieldTitle,
	FieldBody,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldClosedAt,
	FieldMergedAt,
	FieldMergeCommitSha,
	FieldHead,
	FieldBase,
	FieldDraft,
	FieldAuthorAssociation,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "pull_requests"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"issue_pull_request",
	"repository_pull_requests",
	"user_prs_created",
	"user_prs_merged",
}

var (
	// AssigneesPrimaryKey and AssigneesColumn2 are the table columns denoting the
	// primary key for the assignees relation (M2M).
	AssigneesPrimaryKey = []string{"pull_request_id", "user_id"}
	// RequestedReviewersPrimaryKey and RequestedReviewersColumn2 are the table columns denoting the
	// primary key for the requested_reviewers relation (M2M).
	RequestedReviewersPrimaryKey = []string{"pull_request_id", "user_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

// State defines the type for the "state" enum field.
type State string

// State values.
const (
	StateOpen   State = "open"
	StateClosed State = "closed"
)

func (s State) String() string {
	return string(s)
}

// StateValidator is a validator for the "state" field enum values. It is called by the builders before save.
func StateValidator(s State) error {
	switch s {
	case StateOpen, StateClosed:
		return nil
	default:
		return fmt.Errorf("pullrequest: invalid enum value for state field: %q", s)
	}
}

// AuthorAssociationValidator is a validator for the "author_association" field enum values. It is called by the builders before save.
func AuthorAssociationValidator(aa model.AuthorAssociation) error {
	switch aa {
	case "COLLABORATOR", "CONTRIBUTOR", "FIRST_TIMER", "FIRST_TIME_CONTRIBUTOR", "MANNEQUIN", "MEMBER", "OWNER", "NONE":
		return nil
	default:
		return fmt.Errorf("pullrequest: invalid enum value for author_association field: %q", aa)
	}
}

// OrderOption defines the ordering options for the PullRequest queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByURL orders the results by the url field.
func ByURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldURL, opts...).ToFunc()
}

// ByNodeID orders the results by the node_id field.
func ByNodeID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNodeID, opts...).ToFunc()
}

// ByHTMLURL orders the results by the html_url field.
func ByHTMLURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldHTMLURL, opts...).ToFunc()
}

// ByDiffURL orders the results by the diff_url field.
func ByDiffURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDiffURL, opts...).ToFunc()
}

// ByPatchURL orders the results by the patch_url field.
func ByPatchURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPatchURL, opts...).ToFunc()
}

// ByIssueURL orders the results by the issue_url field.
func ByIssueURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIssueURL, opts...).ToFunc()
}

// ByCommitsURL orders the results by the commits_url field.
func ByCommitsURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCommitsURL, opts...).ToFunc()
}

// ByReviewCommentsURL orders the results by the review_comments_url field.
func ByReviewCommentsURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReviewCommentsURL, opts...).ToFunc()
}

// ByReviewCommentURL orders the results by the review_comment_url field.
func ByReviewCommentURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReviewCommentURL, opts...).ToFunc()
}

// ByCommentsURL orders the results by the comments_url field.
func ByCommentsURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCommentsURL, opts...).ToFunc()
}

// ByStatusesURL orders the results by the statuses_url field.
func ByStatusesURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatusesURL, opts...).ToFunc()
}

// ByNumber orders the results by the number field.
func ByNumber(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNumber, opts...).ToFunc()
}

// ByState orders the results by the state field.
func ByState(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldState, opts...).ToFunc()
}

// ByLocked orders the results by the locked field.
func ByLocked(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLocked, opts...).ToFunc()
}

// ByTitle orders the results by the title field.
func ByTitle(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTitle, opts...).ToFunc()
}

// ByBody orders the results by the body field.
func ByBody(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBody, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByClosedAt orders the results by the closed_at field.
func ByClosedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldClosedAt, opts...).ToFunc()
}

// ByMergedAt orders the results by the merged_at field.
func ByMergedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMergedAt, opts...).ToFunc()
}

// ByMergeCommitSha orders the results by the merge_commit_sha field.
func ByMergeCommitSha(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMergeCommitSha, opts...).ToFunc()
}

// ByDraft orders the results by the draft field.
func ByDraft(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDraft, opts...).ToFunc()
}

// ByAuthorAssociation orders the results by the author_association field.
func ByAuthorAssociation(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAuthorAssociation, opts...).ToFunc()
}

// ByRepositoryField orders the results by repository field.
func ByRepositoryField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newRepositoryStep(), sql.OrderByField(field, opts...))
	}
}

// ByIssueField orders the results by issue field.
func ByIssueField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newIssueStep(), sql.OrderByField(field, opts...))
	}
}

// ByUserField orders the results by user field.
func ByUserField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUserStep(), sql.OrderByField(field, opts...))
	}
}

// ByMergedByField orders the results by merged_by field.
func ByMergedByField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newMergedByStep(), sql.OrderByField(field, opts...))
	}
}

// ByAssigneesCount orders the results by assignees count.
func ByAssigneesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAssigneesStep(), opts...)
	}
}

// ByAssignees orders the results by assignees terms.
func ByAssignees(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAssigneesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByRequestedReviewersCount orders the results by requested_reviewers count.
func ByRequestedReviewersCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newRequestedReviewersStep(), opts...)
	}
}

// ByRequestedReviewers orders the results by requested_reviewers terms.
func ByRequestedReviewers(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newRequestedReviewersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newRepositoryStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(RepositoryInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, RepositoryTable, RepositoryColumn),
	)
}
func newIssueStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(IssueInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, true, IssueTable, IssueColumn),
	)
}
func newUserStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UserInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
	)
}
func newMergedByStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(MergedByInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, MergedByTable, MergedByColumn),
	)
}
func newAssigneesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AssigneesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, AssigneesTable, AssigneesPrimaryKey...),
	)
}
func newRequestedReviewersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(RequestedReviewersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, RequestedReviewersTable, RequestedReviewersPrimaryKey...),
	)
}
