// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/gnolang/gh-sql/ent/issue"
	"github.com/gnolang/gh-sql/ent/issuecomment"
	"github.com/gnolang/gh-sql/ent/predicate"
	"github.com/gnolang/gh-sql/ent/repository"
	"github.com/gnolang/gh-sql/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeIssue        = "Issue"
	TypeIssueComment = "IssueComment"
	TypeRepository   = "Repository"
	TypeUser         = "User"
)

// IssueMutation represents an operation that mutates the Issue nodes in the graph.
type IssueMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	node_id            *string
	url                *string
	repository_url     *string
	labels_url         *string
	comments_url       *string
	events_url         *string
	html_url           *string
	number             *int64
	addnumber          *int64
	state              *string
	state_reason       *issue.StateReason
	title              *string
	body               *string
	locked             *bool
	active_lock_reason *string
	closed_at          *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	draft              *bool
	clearedFields      map[string]struct{}
	repository         *int64
	clearedrepository  bool
	user               *int64
	cleareduser        bool
	assignees          map[int64]struct{}
	removedassignees   map[int64]struct{}
	clearedassignees   bool
	closed_by          *int64
	clearedclosed_by   bool
	comments           map[int64]struct{}
	removedcomments    map[int64]struct{}
	clearedcomments    bool
	done               bool
	oldValue           func(context.Context) (*Issue, error)
	predicates         []predicate.Issue
}

var _ ent.Mutation = (*IssueMutation)(nil)

// issueOption allows management of the mutation configuration using functional options.
type issueOption func(*IssueMutation)

// newIssueMutation creates new mutation for the Issue entity.
func newIssueMutation(c config, op Op, opts ...issueOption) *IssueMutation {
	m := &IssueMutation{
		config:        c,
		op:            op,
		typ:           TypeIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssueID sets the ID field of the mutation.
func withIssueID(id int64) issueOption {
	return func(m *IssueMutation) {
		var (
			err   error
			once  sync.Once
			value *Issue
		)
		m.oldValue = func(ctx context.Context) (*Issue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Issue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssue sets the old Issue of the mutation.
func withIssue(node *Issue) issueOption {
	return func(m *IssueMutation) {
		m.oldValue = func(context.Context) (*Issue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Issue entities.
func (m *IssueMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssueMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Issue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodeID sets the "node_id" field.
func (m *IssueMutation) SetNodeID(s string) {
	m.node_id = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *IssueMutation) NodeID() (r string, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *IssueMutation) ResetNodeID() {
	m.node_id = nil
}

// SetURL sets the "url" field.
func (m *IssueMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *IssueMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *IssueMutation) ResetURL() {
	m.url = nil
}

// SetRepositoryURL sets the "repository_url" field.
func (m *IssueMutation) SetRepositoryURL(s string) {
	m.repository_url = &s
}

// RepositoryURL returns the value of the "repository_url" field in the mutation.
func (m *IssueMutation) RepositoryURL() (r string, exists bool) {
	v := m.repository_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRepositoryURL returns the old "repository_url" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldRepositoryURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepositoryURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepositoryURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepositoryURL: %w", err)
	}
	return oldValue.RepositoryURL, nil
}

// ResetRepositoryURL resets all changes to the "repository_url" field.
func (m *IssueMutation) ResetRepositoryURL() {
	m.repository_url = nil
}

// SetLabelsURL sets the "labels_url" field.
func (m *IssueMutation) SetLabelsURL(s string) {
	m.labels_url = &s
}

// LabelsURL returns the value of the "labels_url" field in the mutation.
func (m *IssueMutation) LabelsURL() (r string, exists bool) {
	v := m.labels_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelsURL returns the old "labels_url" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldLabelsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelsURL: %w", err)
	}
	return oldValue.LabelsURL, nil
}

// ResetLabelsURL resets all changes to the "labels_url" field.
func (m *IssueMutation) ResetLabelsURL() {
	m.labels_url = nil
}

// SetCommentsURL sets the "comments_url" field.
func (m *IssueMutation) SetCommentsURL(s string) {
	m.comments_url = &s
}

// CommentsURL returns the value of the "comments_url" field in the mutation.
func (m *IssueMutation) CommentsURL() (r string, exists bool) {
	v := m.comments_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentsURL returns the old "comments_url" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldCommentsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentsURL: %w", err)
	}
	return oldValue.CommentsURL, nil
}

// ResetCommentsURL resets all changes to the "comments_url" field.
func (m *IssueMutation) ResetCommentsURL() {
	m.comments_url = nil
}

// SetEventsURL sets the "events_url" field.
func (m *IssueMutation) SetEventsURL(s string) {
	m.events_url = &s
}

// EventsURL returns the value of the "events_url" field in the mutation.
func (m *IssueMutation) EventsURL() (r string, exists bool) {
	v := m.events_url
	if v == nil {
		return
	}
	return *v, true
}

// OldEventsURL returns the old "events_url" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldEventsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventsURL: %w", err)
	}
	return oldValue.EventsURL, nil
}

// ResetEventsURL resets all changes to the "events_url" field.
func (m *IssueMutation) ResetEventsURL() {
	m.events_url = nil
}

// SetHTMLURL sets the "html_url" field.
func (m *IssueMutation) SetHTMLURL(s string) {
	m.html_url = &s
}

// HTMLURL returns the value of the "html_url" field in the mutation.
func (m *IssueMutation) HTMLURL() (r string, exists bool) {
	v := m.html_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLURL returns the old "html_url" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldHTMLURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLURL: %w", err)
	}
	return oldValue.HTMLURL, nil
}

// ResetHTMLURL resets all changes to the "html_url" field.
func (m *IssueMutation) ResetHTMLURL() {
	m.html_url = nil
}

// SetNumber sets the "number" field.
func (m *IssueMutation) SetNumber(i int64) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *IssueMutation) Number() (r int64, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *IssueMutation) AddNumber(i int64) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *IssueMutation) AddedNumber() (r int64, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *IssueMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetState sets the "state" field.
func (m *IssueMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *IssueMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *IssueMutation) ResetState() {
	m.state = nil
}

// SetStateReason sets the "state_reason" field.
func (m *IssueMutation) SetStateReason(ir issue.StateReason) {
	m.state_reason = &ir
}

// StateReason returns the value of the "state_reason" field in the mutation.
func (m *IssueMutation) StateReason() (r issue.StateReason, exists bool) {
	v := m.state_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldStateReason returns the old "state_reason" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldStateReason(ctx context.Context) (v *issue.StateReason, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateReason: %w", err)
	}
	return oldValue.StateReason, nil
}

// ClearStateReason clears the value of the "state_reason" field.
func (m *IssueMutation) ClearStateReason() {
	m.state_reason = nil
	m.clearedFields[issue.FieldStateReason] = struct{}{}
}

// StateReasonCleared returns if the "state_reason" field was cleared in this mutation.
func (m *IssueMutation) StateReasonCleared() bool {
	_, ok := m.clearedFields[issue.FieldStateReason]
	return ok
}

// ResetStateReason resets all changes to the "state_reason" field.
func (m *IssueMutation) ResetStateReason() {
	m.state_reason = nil
	delete(m.clearedFields, issue.FieldStateReason)
}

// SetTitle sets the "title" field.
func (m *IssueMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IssueMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IssueMutation) ResetTitle() {
	m.title = nil
}

// SetBody sets the "body" field.
func (m *IssueMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *IssueMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *IssueMutation) ClearBody() {
	m.body = nil
	m.clearedFields[issue.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *IssueMutation) BodyCleared() bool {
	_, ok := m.clearedFields[issue.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *IssueMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, issue.FieldBody)
}

// SetLocked sets the "locked" field.
func (m *IssueMutation) SetLocked(b bool) {
	m.locked = &b
}

// Locked returns the value of the "locked" field in the mutation.
func (m *IssueMutation) Locked() (r bool, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldLocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ResetLocked resets all changes to the "locked" field.
func (m *IssueMutation) ResetLocked() {
	m.locked = nil
}

// SetActiveLockReason sets the "active_lock_reason" field.
func (m *IssueMutation) SetActiveLockReason(s string) {
	m.active_lock_reason = &s
}

// ActiveLockReason returns the value of the "active_lock_reason" field in the mutation.
func (m *IssueMutation) ActiveLockReason() (r string, exists bool) {
	v := m.active_lock_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveLockReason returns the old "active_lock_reason" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldActiveLockReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveLockReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveLockReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveLockReason: %w", err)
	}
	return oldValue.ActiveLockReason, nil
}

// ClearActiveLockReason clears the value of the "active_lock_reason" field.
func (m *IssueMutation) ClearActiveLockReason() {
	m.active_lock_reason = nil
	m.clearedFields[issue.FieldActiveLockReason] = struct{}{}
}

// ActiveLockReasonCleared returns if the "active_lock_reason" field was cleared in this mutation.
func (m *IssueMutation) ActiveLockReasonCleared() bool {
	_, ok := m.clearedFields[issue.FieldActiveLockReason]
	return ok
}

// ResetActiveLockReason resets all changes to the "active_lock_reason" field.
func (m *IssueMutation) ResetActiveLockReason() {
	m.active_lock_reason = nil
	delete(m.clearedFields, issue.FieldActiveLockReason)
}

// SetClosedAt sets the "closed_at" field.
func (m *IssueMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *IssueMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldClosedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ClearClosedAt clears the value of the "closed_at" field.
func (m *IssueMutation) ClearClosedAt() {
	m.closed_at = nil
	m.clearedFields[issue.FieldClosedAt] = struct{}{}
}

// ClosedAtCleared returns if the "closed_at" field was cleared in this mutation.
func (m *IssueMutation) ClosedAtCleared() bool {
	_, ok := m.clearedFields[issue.FieldClosedAt]
	return ok
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *IssueMutation) ResetClosedAt() {
	m.closed_at = nil
	delete(m.clearedFields, issue.FieldClosedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *IssueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IssueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IssueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IssueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IssueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IssueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDraft sets the "draft" field.
func (m *IssueMutation) SetDraft(b bool) {
	m.draft = &b
}

// Draft returns the value of the "draft" field in the mutation.
func (m *IssueMutation) Draft() (r bool, exists bool) {
	v := m.draft
	if v == nil {
		return
	}
	return *v, true
}

// OldDraft returns the old "draft" field's value of the Issue entity.
// If the Issue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueMutation) OldDraft(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDraft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDraft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDraft: %w", err)
	}
	return oldValue.Draft, nil
}

// ResetDraft resets all changes to the "draft" field.
func (m *IssueMutation) ResetDraft() {
	m.draft = nil
}

// SetRepositoryID sets the "repository" edge to the Repository entity by id.
func (m *IssueMutation) SetRepositoryID(id int64) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the Repository entity.
func (m *IssueMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the Repository entity was cleared.
func (m *IssueMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *IssueMutation) RepositoryID() (id int64, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *IssueMutation) RepositoryIDs() (ids []int64) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *IssueMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *IssueMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *IssueMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IssueMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *IssueMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IssueMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IssueMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddAssigneeIDs adds the "assignees" edge to the User entity by ids.
func (m *IssueMutation) AddAssigneeIDs(ids ...int64) {
	if m.assignees == nil {
		m.assignees = make(map[int64]struct{})
	}
	for i := range ids {
		m.assignees[ids[i]] = struct{}{}
	}
}

// ClearAssignees clears the "assignees" edge to the User entity.
func (m *IssueMutation) ClearAssignees() {
	m.clearedassignees = true
}

// AssigneesCleared reports if the "assignees" edge to the User entity was cleared.
func (m *IssueMutation) AssigneesCleared() bool {
	return m.clearedassignees
}

// RemoveAssigneeIDs removes the "assignees" edge to the User entity by IDs.
func (m *IssueMutation) RemoveAssigneeIDs(ids ...int64) {
	if m.removedassignees == nil {
		m.removedassignees = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.assignees, ids[i])
		m.removedassignees[ids[i]] = struct{}{}
	}
}

// RemovedAssignees returns the removed IDs of the "assignees" edge to the User entity.
func (m *IssueMutation) RemovedAssigneesIDs() (ids []int64) {
	for id := range m.removedassignees {
		ids = append(ids, id)
	}
	return
}

// AssigneesIDs returns the "assignees" edge IDs in the mutation.
func (m *IssueMutation) AssigneesIDs() (ids []int64) {
	for id := range m.assignees {
		ids = append(ids, id)
	}
	return
}

// ResetAssignees resets all changes to the "assignees" edge.
func (m *IssueMutation) ResetAssignees() {
	m.assignees = nil
	m.clearedassignees = false
	m.removedassignees = nil
}

// SetClosedByID sets the "closed_by" edge to the User entity by id.
func (m *IssueMutation) SetClosedByID(id int64) {
	m.closed_by = &id
}

// ClearClosedBy clears the "closed_by" edge to the User entity.
func (m *IssueMutation) ClearClosedBy() {
	m.clearedclosed_by = true
}

// ClosedByCleared reports if the "closed_by" edge to the User entity was cleared.
func (m *IssueMutation) ClosedByCleared() bool {
	return m.clearedclosed_by
}

// ClosedByID returns the "closed_by" edge ID in the mutation.
func (m *IssueMutation) ClosedByID() (id int64, exists bool) {
	if m.closed_by != nil {
		return *m.closed_by, true
	}
	return
}

// ClosedByIDs returns the "closed_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClosedByID instead. It exists only for internal usage by the builders.
func (m *IssueMutation) ClosedByIDs() (ids []int64) {
	if id := m.closed_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClosedBy resets all changes to the "closed_by" edge.
func (m *IssueMutation) ResetClosedBy() {
	m.closed_by = nil
	m.clearedclosed_by = false
}

// AddCommentIDs adds the "comments" edge to the IssueComment entity by ids.
func (m *IssueMutation) AddCommentIDs(ids ...int64) {
	if m.comments == nil {
		m.comments = make(map[int64]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the IssueComment entity.
func (m *IssueMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the IssueComment entity was cleared.
func (m *IssueMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the IssueComment entity by IDs.
func (m *IssueMutation) RemoveCommentIDs(ids ...int64) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the IssueComment entity.
func (m *IssueMutation) RemovedCommentsIDs() (ids []int64) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *IssueMutation) CommentsIDs() (ids []int64) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *IssueMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// Where appends a list predicates to the IssueMutation builder.
func (m *IssueMutation) Where(ps ...predicate.Issue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Issue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Issue).
func (m *IssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssueMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.node_id != nil {
		fields = append(fields, issue.FieldNodeID)
	}
	if m.url != nil {
		fields = append(fields, issue.FieldURL)
	}
	if m.repository_url != nil {
		fields = append(fields, issue.FieldRepositoryURL)
	}
	if m.labels_url != nil {
		fields = append(fields, issue.FieldLabelsURL)
	}
	if m.comments_url != nil {
		fields = append(fields, issue.FieldCommentsURL)
	}
	if m.events_url != nil {
		fields = append(fields, issue.FieldEventsURL)
	}
	if m.html_url != nil {
		fields = append(fields, issue.FieldHTMLURL)
	}
	if m.number != nil {
		fields = append(fields, issue.FieldNumber)
	}
	if m.state != nil {
		fields = append(fields, issue.FieldState)
	}
	if m.state_reason != nil {
		fields = append(fields, issue.FieldStateReason)
	}
	if m.title != nil {
		fields = append(fields, issue.FieldTitle)
	}
	if m.body != nil {
		fields = append(fields, issue.FieldBody)
	}
	if m.locked != nil {
		fields = append(fields, issue.FieldLocked)
	}
	if m.active_lock_reason != nil {
		fields = append(fields, issue.FieldActiveLockReason)
	}
	if m.closed_at != nil {
		fields = append(fields, issue.FieldClosedAt)
	}
	if m.created_at != nil {
		fields = append(fields, issue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, issue.FieldUpdatedAt)
	}
	if m.draft != nil {
		fields = append(fields, issue.FieldDraft)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case issue.FieldNodeID:
		return m.NodeID()
	case issue.FieldURL:
		return m.URL()
	case issue.FieldRepositoryURL:
		return m.RepositoryURL()
	case issue.FieldLabelsURL:
		return m.LabelsURL()
	case issue.FieldCommentsURL:
		return m.CommentsURL()
	case issue.FieldEventsURL:
		return m.EventsURL()
	case issue.FieldHTMLURL:
		return m.HTMLURL()
	case issue.FieldNumber:
		return m.Number()
	case issue.FieldState:
		return m.State()
	case issue.FieldStateReason:
		return m.StateReason()
	case issue.FieldTitle:
		return m.Title()
	case issue.FieldBody:
		return m.Body()
	case issue.FieldLocked:
		return m.Locked()
	case issue.FieldActiveLockReason:
		return m.ActiveLockReason()
	case issue.FieldClosedAt:
		return m.ClosedAt()
	case issue.FieldCreatedAt:
		return m.CreatedAt()
	case issue.FieldUpdatedAt:
		return m.UpdatedAt()
	case issue.FieldDraft:
		return m.Draft()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case issue.FieldNodeID:
		return m.OldNodeID(ctx)
	case issue.FieldURL:
		return m.OldURL(ctx)
	case issue.FieldRepositoryURL:
		return m.OldRepositoryURL(ctx)
	case issue.FieldLabelsURL:
		return m.OldLabelsURL(ctx)
	case issue.FieldCommentsURL:
		return m.OldCommentsURL(ctx)
	case issue.FieldEventsURL:
		return m.OldEventsURL(ctx)
	case issue.FieldHTMLURL:
		return m.OldHTMLURL(ctx)
	case issue.FieldNumber:
		return m.OldNumber(ctx)
	case issue.FieldState:
		return m.OldState(ctx)
	case issue.FieldStateReason:
		return m.OldStateReason(ctx)
	case issue.FieldTitle:
		return m.OldTitle(ctx)
	case issue.FieldBody:
		return m.OldBody(ctx)
	case issue.FieldLocked:
		return m.OldLocked(ctx)
	case issue.FieldActiveLockReason:
		return m.OldActiveLockReason(ctx)
	case issue.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case issue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case issue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case issue.FieldDraft:
		return m.OldDraft(ctx)
	}
	return nil, fmt.Errorf("unknown Issue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case issue.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case issue.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case issue.FieldRepositoryURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepositoryURL(v)
		return nil
	case issue.FieldLabelsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelsURL(v)
		return nil
	case issue.FieldCommentsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentsURL(v)
		return nil
	case issue.FieldEventsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventsURL(v)
		return nil
	case issue.FieldHTMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLURL(v)
		return nil
	case issue.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case issue.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case issue.FieldStateReason:
		v, ok := value.(issue.StateReason)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateReason(v)
		return nil
	case issue.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case issue.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case issue.FieldLocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case issue.FieldActiveLockReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveLockReason(v)
		return nil
	case issue.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case issue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case issue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case issue.FieldDraft:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDraft(v)
		return nil
	}
	return fmt.Errorf("unknown Issue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssueMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, issue.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case issue.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case issue.FieldNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Issue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(issue.FieldStateReason) {
		fields = append(fields, issue.FieldStateReason)
	}
	if m.FieldCleared(issue.FieldBody) {
		fields = append(fields, issue.FieldBody)
	}
	if m.FieldCleared(issue.FieldActiveLockReason) {
		fields = append(fields, issue.FieldActiveLockReason)
	}
	if m.FieldCleared(issue.FieldClosedAt) {
		fields = append(fields, issue.FieldClosedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssueMutation) ClearField(name string) error {
	switch name {
	case issue.FieldStateReason:
		m.ClearStateReason()
		return nil
	case issue.FieldBody:
		m.ClearBody()
		return nil
	case issue.FieldActiveLockReason:
		m.ClearActiveLockReason()
		return nil
	case issue.FieldClosedAt:
		m.ClearClosedAt()
		return nil
	}
	return fmt.Errorf("unknown Issue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssueMutation) ResetField(name string) error {
	switch name {
	case issue.FieldNodeID:
		m.ResetNodeID()
		return nil
	case issue.FieldURL:
		m.ResetURL()
		return nil
	case issue.FieldRepositoryURL:
		m.ResetRepositoryURL()
		return nil
	case issue.FieldLabelsURL:
		m.ResetLabelsURL()
		return nil
	case issue.FieldCommentsURL:
		m.ResetCommentsURL()
		return nil
	case issue.FieldEventsURL:
		m.ResetEventsURL()
		return nil
	case issue.FieldHTMLURL:
		m.ResetHTMLURL()
		return nil
	case issue.FieldNumber:
		m.ResetNumber()
		return nil
	case issue.FieldState:
		m.ResetState()
		return nil
	case issue.FieldStateReason:
		m.ResetStateReason()
		return nil
	case issue.FieldTitle:
		m.ResetTitle()
		return nil
	case issue.FieldBody:
		m.ResetBody()
		return nil
	case issue.FieldLocked:
		m.ResetLocked()
		return nil
	case issue.FieldActiveLockReason:
		m.ResetActiveLockReason()
		return nil
	case issue.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case issue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case issue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case issue.FieldDraft:
		m.ResetDraft()
		return nil
	}
	return fmt.Errorf("unknown Issue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.repository != nil {
		edges = append(edges, issue.EdgeRepository)
	}
	if m.user != nil {
		edges = append(edges, issue.EdgeUser)
	}
	if m.assignees != nil {
		edges = append(edges, issue.EdgeAssignees)
	}
	if m.closed_by != nil {
		edges = append(edges, issue.EdgeClosedBy)
	}
	if m.comments != nil {
		edges = append(edges, issue.EdgeComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case issue.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	case issue.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case issue.EdgeAssignees:
		ids := make([]ent.Value, 0, len(m.assignees))
		for id := range m.assignees {
			ids = append(ids, id)
		}
		return ids
	case issue.EdgeClosedBy:
		if id := m.closed_by; id != nil {
			return []ent.Value{*id}
		}
	case issue.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedassignees != nil {
		edges = append(edges, issue.EdgeAssignees)
	}
	if m.removedcomments != nil {
		edges = append(edges, issue.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case issue.EdgeAssignees:
		ids := make([]ent.Value, 0, len(m.removedassignees))
		for id := range m.removedassignees {
			ids = append(ids, id)
		}
		return ids
	case issue.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrepository {
		edges = append(edges, issue.EdgeRepository)
	}
	if m.cleareduser {
		edges = append(edges, issue.EdgeUser)
	}
	if m.clearedassignees {
		edges = append(edges, issue.EdgeAssignees)
	}
	if m.clearedclosed_by {
		edges = append(edges, issue.EdgeClosedBy)
	}
	if m.clearedcomments {
		edges = append(edges, issue.EdgeComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssueMutation) EdgeCleared(name string) bool {
	switch name {
	case issue.EdgeRepository:
		return m.clearedrepository
	case issue.EdgeUser:
		return m.cleareduser
	case issue.EdgeAssignees:
		return m.clearedassignees
	case issue.EdgeClosedBy:
		return m.clearedclosed_by
	case issue.EdgeComments:
		return m.clearedcomments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssueMutation) ClearEdge(name string) error {
	switch name {
	case issue.EdgeRepository:
		m.ClearRepository()
		return nil
	case issue.EdgeUser:
		m.ClearUser()
		return nil
	case issue.EdgeClosedBy:
		m.ClearClosedBy()
		return nil
	}
	return fmt.Errorf("unknown Issue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssueMutation) ResetEdge(name string) error {
	switch name {
	case issue.EdgeRepository:
		m.ResetRepository()
		return nil
	case issue.EdgeUser:
		m.ResetUser()
		return nil
	case issue.EdgeAssignees:
		m.ResetAssignees()
		return nil
	case issue.EdgeClosedBy:
		m.ResetClosedBy()
		return nil
	case issue.EdgeComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown Issue edge %s", name)
}

// IssueCommentMutation represents an operation that mutates the IssueComment nodes in the graph.
type IssueCommentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	node_id            *string
	url                *string
	body               *string
	html_url           *string
	created_at         *string
	updated_at         *string
	issue_url          *string
	author_association *issuecomment.AuthorAssociation
	reactions          *map[string]interface{}
	clearedFields      map[string]struct{}
	issue              *int64
	clearedissue       bool
	user               *int64
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*IssueComment, error)
	predicates         []predicate.IssueComment
}

var _ ent.Mutation = (*IssueCommentMutation)(nil)

// issuecommentOption allows management of the mutation configuration using functional options.
type issuecommentOption func(*IssueCommentMutation)

// newIssueCommentMutation creates new mutation for the IssueComment entity.
func newIssueCommentMutation(c config, op Op, opts ...issuecommentOption) *IssueCommentMutation {
	m := &IssueCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeIssueComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssueCommentID sets the ID field of the mutation.
func withIssueCommentID(id int64) issuecommentOption {
	return func(m *IssueCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *IssueComment
		)
		m.oldValue = func(ctx context.Context) (*IssueComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IssueComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssueComment sets the old IssueComment of the mutation.
func withIssueComment(node *IssueComment) issuecommentOption {
	return func(m *IssueCommentMutation) {
		m.oldValue = func(context.Context) (*IssueComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssueCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssueCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IssueComment entities.
func (m *IssueCommentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssueCommentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssueCommentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IssueComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodeID sets the "node_id" field.
func (m *IssueCommentMutation) SetNodeID(s string) {
	m.node_id = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *IssueCommentMutation) NodeID() (r string, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the IssueComment entity.
// If the IssueComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueCommentMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *IssueCommentMutation) ResetNodeID() {
	m.node_id = nil
}

// SetURL sets the "url" field.
func (m *IssueCommentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *IssueCommentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the IssueComment entity.
// If the IssueComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueCommentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *IssueCommentMutation) ResetURL() {
	m.url = nil
}

// SetBody sets the "body" field.
func (m *IssueCommentMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *IssueCommentMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the IssueComment entity.
// If the IssueComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueCommentMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *IssueCommentMutation) ResetBody() {
	m.body = nil
}

// SetHTMLURL sets the "html_url" field.
func (m *IssueCommentMutation) SetHTMLURL(s string) {
	m.html_url = &s
}

// HTMLURL returns the value of the "html_url" field in the mutation.
func (m *IssueCommentMutation) HTMLURL() (r string, exists bool) {
	v := m.html_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLURL returns the old "html_url" field's value of the IssueComment entity.
// If the IssueComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueCommentMutation) OldHTMLURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLURL: %w", err)
	}
	return oldValue.HTMLURL, nil
}

// ResetHTMLURL resets all changes to the "html_url" field.
func (m *IssueCommentMutation) ResetHTMLURL() {
	m.html_url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IssueCommentMutation) SetCreatedAt(s string) {
	m.created_at = &s
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IssueCommentMutation) CreatedAt() (r string, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IssueComment entity.
// If the IssueComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueCommentMutation) OldCreatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IssueCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IssueCommentMutation) SetUpdatedAt(s string) {
	m.updated_at = &s
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IssueCommentMutation) UpdatedAt() (r string, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IssueComment entity.
// If the IssueComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueCommentMutation) OldUpdatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IssueCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIssueURL sets the "issue_url" field.
func (m *IssueCommentMutation) SetIssueURL(s string) {
	m.issue_url = &s
}

// IssueURL returns the value of the "issue_url" field in the mutation.
func (m *IssueCommentMutation) IssueURL() (r string, exists bool) {
	v := m.issue_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueURL returns the old "issue_url" field's value of the IssueComment entity.
// If the IssueComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueCommentMutation) OldIssueURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueURL: %w", err)
	}
	return oldValue.IssueURL, nil
}

// ResetIssueURL resets all changes to the "issue_url" field.
func (m *IssueCommentMutation) ResetIssueURL() {
	m.issue_url = nil
}

// SetAuthorAssociation sets the "author_association" field.
func (m *IssueCommentMutation) SetAuthorAssociation(ia issuecomment.AuthorAssociation) {
	m.author_association = &ia
}

// AuthorAssociation returns the value of the "author_association" field in the mutation.
func (m *IssueCommentMutation) AuthorAssociation() (r issuecomment.AuthorAssociation, exists bool) {
	v := m.author_association
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorAssociation returns the old "author_association" field's value of the IssueComment entity.
// If the IssueComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueCommentMutation) OldAuthorAssociation(ctx context.Context) (v issuecomment.AuthorAssociation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorAssociation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorAssociation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorAssociation: %w", err)
	}
	return oldValue.AuthorAssociation, nil
}

// ResetAuthorAssociation resets all changes to the "author_association" field.
func (m *IssueCommentMutation) ResetAuthorAssociation() {
	m.author_association = nil
}

// SetReactions sets the "reactions" field.
func (m *IssueCommentMutation) SetReactions(value map[string]interface{}) {
	m.reactions = &value
}

// Reactions returns the value of the "reactions" field in the mutation.
func (m *IssueCommentMutation) Reactions() (r map[string]interface{}, exists bool) {
	v := m.reactions
	if v == nil {
		return
	}
	return *v, true
}

// OldReactions returns the old "reactions" field's value of the IssueComment entity.
// If the IssueComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueCommentMutation) OldReactions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReactions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReactions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReactions: %w", err)
	}
	return oldValue.Reactions, nil
}

// ResetReactions resets all changes to the "reactions" field.
func (m *IssueCommentMutation) ResetReactions() {
	m.reactions = nil
}

// SetIssueID sets the "issue" edge to the Issue entity by id.
func (m *IssueCommentMutation) SetIssueID(id int64) {
	m.issue = &id
}

// ClearIssue clears the "issue" edge to the Issue entity.
func (m *IssueCommentMutation) ClearIssue() {
	m.clearedissue = true
}

// IssueCleared reports if the "issue" edge to the Issue entity was cleared.
func (m *IssueCommentMutation) IssueCleared() bool {
	return m.clearedissue
}

// IssueID returns the "issue" edge ID in the mutation.
func (m *IssueCommentMutation) IssueID() (id int64, exists bool) {
	if m.issue != nil {
		return *m.issue, true
	}
	return
}

// IssueIDs returns the "issue" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssueID instead. It exists only for internal usage by the builders.
func (m *IssueCommentMutation) IssueIDs() (ids []int64) {
	if id := m.issue; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssue resets all changes to the "issue" edge.
func (m *IssueCommentMutation) ResetIssue() {
	m.issue = nil
	m.clearedissue = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *IssueCommentMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *IssueCommentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IssueCommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *IssueCommentMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IssueCommentMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IssueCommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the IssueCommentMutation builder.
func (m *IssueCommentMutation) Where(ps ...predicate.IssueComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssueCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssueCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IssueComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssueCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssueCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IssueComment).
func (m *IssueCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssueCommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.node_id != nil {
		fields = append(fields, issuecomment.FieldNodeID)
	}
	if m.url != nil {
		fields = append(fields, issuecomment.FieldURL)
	}
	if m.body != nil {
		fields = append(fields, issuecomment.FieldBody)
	}
	if m.html_url != nil {
		fields = append(fields, issuecomment.FieldHTMLURL)
	}
	if m.created_at != nil {
		fields = append(fields, issuecomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, issuecomment.FieldUpdatedAt)
	}
	if m.issue_url != nil {
		fields = append(fields, issuecomment.FieldIssueURL)
	}
	if m.author_association != nil {
		fields = append(fields, issuecomment.FieldAuthorAssociation)
	}
	if m.reactions != nil {
		fields = append(fields, issuecomment.FieldReactions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssueCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case issuecomment.FieldNodeID:
		return m.NodeID()
	case issuecomment.FieldURL:
		return m.URL()
	case issuecomment.FieldBody:
		return m.Body()
	case issuecomment.FieldHTMLURL:
		return m.HTMLURL()
	case issuecomment.FieldCreatedAt:
		return m.CreatedAt()
	case issuecomment.FieldUpdatedAt:
		return m.UpdatedAt()
	case issuecomment.FieldIssueURL:
		return m.IssueURL()
	case issuecomment.FieldAuthorAssociation:
		return m.AuthorAssociation()
	case issuecomment.FieldReactions:
		return m.Reactions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssueCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case issuecomment.FieldNodeID:
		return m.OldNodeID(ctx)
	case issuecomment.FieldURL:
		return m.OldURL(ctx)
	case issuecomment.FieldBody:
		return m.OldBody(ctx)
	case issuecomment.FieldHTMLURL:
		return m.OldHTMLURL(ctx)
	case issuecomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case issuecomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case issuecomment.FieldIssueURL:
		return m.OldIssueURL(ctx)
	case issuecomment.FieldAuthorAssociation:
		return m.OldAuthorAssociation(ctx)
	case issuecomment.FieldReactions:
		return m.OldReactions(ctx)
	}
	return nil, fmt.Errorf("unknown IssueComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case issuecomment.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case issuecomment.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case issuecomment.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case issuecomment.FieldHTMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLURL(v)
		return nil
	case issuecomment.FieldCreatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case issuecomment.FieldUpdatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case issuecomment.FieldIssueURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueURL(v)
		return nil
	case issuecomment.FieldAuthorAssociation:
		v, ok := value.(issuecomment.AuthorAssociation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorAssociation(v)
		return nil
	case issuecomment.FieldReactions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReactions(v)
		return nil
	}
	return fmt.Errorf("unknown IssueComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssueCommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssueCommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IssueComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssueCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssueCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssueCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IssueComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssueCommentMutation) ResetField(name string) error {
	switch name {
	case issuecomment.FieldNodeID:
		m.ResetNodeID()
		return nil
	case issuecomment.FieldURL:
		m.ResetURL()
		return nil
	case issuecomment.FieldBody:
		m.ResetBody()
		return nil
	case issuecomment.FieldHTMLURL:
		m.ResetHTMLURL()
		return nil
	case issuecomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case issuecomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case issuecomment.FieldIssueURL:
		m.ResetIssueURL()
		return nil
	case issuecomment.FieldAuthorAssociation:
		m.ResetAuthorAssociation()
		return nil
	case issuecomment.FieldReactions:
		m.ResetReactions()
		return nil
	}
	return fmt.Errorf("unknown IssueComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssueCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.issue != nil {
		edges = append(edges, issuecomment.EdgeIssue)
	}
	if m.user != nil {
		edges = append(edges, issuecomment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssueCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case issuecomment.EdgeIssue:
		if id := m.issue; id != nil {
			return []ent.Value{*id}
		}
	case issuecomment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssueCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssueCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssueCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedissue {
		edges = append(edges, issuecomment.EdgeIssue)
	}
	if m.cleareduser {
		edges = append(edges, issuecomment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssueCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case issuecomment.EdgeIssue:
		return m.clearedissue
	case issuecomment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssueCommentMutation) ClearEdge(name string) error {
	switch name {
	case issuecomment.EdgeIssue:
		m.ClearIssue()
		return nil
	case issuecomment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown IssueComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssueCommentMutation) ResetEdge(name string) error {
	switch name {
	case issuecomment.EdgeIssue:
		m.ResetIssue()
		return nil
	case issuecomment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown IssueComment edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	node_id              *string
	name                 *string
	full_name            *string
	private              *bool
	html_url             *string
	description          *string
	fork                 *bool
	url                  *string
	archive_url          *string
	assignees_url        *string
	blobs_url            *string
	branches_url         *string
	collaborators_url    *string
	comments_url         *string
	commits_url          *string
	compare_url          *string
	contents_url         *string
	contributors_url     *string
	deployments_url      *string
	downloads_url        *string
	events_url           *string
	forks_url            *string
	git_commits_url      *string
	git_refs_url         *string
	git_tags_url         *string
	git_url              *string
	issue_comment_url    *string
	issue_events_url     *string
	issues_url           *string
	keys_url             *string
	labels_url           *string
	languages_url        *string
	merges_url           *string
	milestones_url       *string
	notifications_url    *string
	pulls_url            *string
	releases_url         *string
	ssh_url              *string
	stargazers_url       *string
	statuses_url         *string
	subscribers_url      *string
	subscription_url     *string
	tags_url             *string
	teams_url            *string
	trees_url            *string
	clone_url            *string
	mirror_url           *string
	hooks_url            *string
	svn_url              *string
	homepage             *string
	language             *string
	forks_count          *int64
	addforks_count       *int64
	stargazers_count     *int64
	addstargazers_count  *int64
	watchers_count       *int64
	addwatchers_count    *int64
	size                 *int64
	addsize              *int64
	default_branch       *string
	open_issues_count    *int64
	addopen_issues_count *int64
	is_template          *bool
	topics               *[]string
	appendtopics         []string
	has_issues_enabled   *bool
	has_projects         *bool
	has_wiki             *bool
	has_pages            *bool
	has_downloads        *bool
	has_discussions      *bool
	archived             *bool
	disabled             *bool
	visibility           *repository.Visibility
	pushed_at            *time.Time
	created_at           *time.Time
	updated_at           *time.Time
	subscribers_count    *int64
	addsubscribers_count *int64
	network_count        *int64
	addnetwork_count     *int64
	forks                *int64
	addforks             *int64
	open_issues          *int64
	addopen_issues       *int64
	watchers             *int64
	addwatchers          *int64
	clearedFields        map[string]struct{}
	owner                *int64
	clearedowner         bool
	issues               map[int64]struct{}
	removedissues        map[int64]struct{}
	clearedissues        bool
	done                 bool
	oldValue             func(context.Context) (*Repository, error)
	predicates           []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id int64) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Repository entities.
func (m *RepositoryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepositoryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Repository.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNodeID sets the "node_id" field.
func (m *RepositoryMutation) SetNodeID(s string) {
	m.node_id = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *RepositoryMutation) NodeID() (r string, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *RepositoryMutation) ResetNodeID() {
	m.node_id = nil
}

// SetName sets the "name" field.
func (m *RepositoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RepositoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RepositoryMutation) ResetName() {
	m.name = nil
}

// SetFullName sets the "full_name" field.
func (m *RepositoryMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *RepositoryMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *RepositoryMutation) ResetFullName() {
	m.full_name = nil
}

// SetPrivate sets the "private" field.
func (m *RepositoryMutation) SetPrivate(b bool) {
	m.private = &b
}

// Private returns the value of the "private" field in the mutation.
func (m *RepositoryMutation) Private() (r bool, exists bool) {
	v := m.private
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivate returns the old "private" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivate: %w", err)
	}
	return oldValue.Private, nil
}

// ResetPrivate resets all changes to the "private" field.
func (m *RepositoryMutation) ResetPrivate() {
	m.private = nil
}

// SetHTMLURL sets the "html_url" field.
func (m *RepositoryMutation) SetHTMLURL(s string) {
	m.html_url = &s
}

// HTMLURL returns the value of the "html_url" field in the mutation.
func (m *RepositoryMutation) HTMLURL() (r string, exists bool) {
	v := m.html_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLURL returns the old "html_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHTMLURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLURL: %w", err)
	}
	return oldValue.HTMLURL, nil
}

// ResetHTMLURL resets all changes to the "html_url" field.
func (m *RepositoryMutation) ResetHTMLURL() {
	m.html_url = nil
}

// SetDescription sets the "description" field.
func (m *RepositoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RepositoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RepositoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[repository.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RepositoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[repository.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RepositoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, repository.FieldDescription)
}

// SetFork sets the "fork" field.
func (m *RepositoryMutation) SetFork(b bool) {
	m.fork = &b
}

// Fork returns the value of the "fork" field in the mutation.
func (m *RepositoryMutation) Fork() (r bool, exists bool) {
	v := m.fork
	if v == nil {
		return
	}
	return *v, true
}

// OldFork returns the old "fork" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldFork(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFork: %w", err)
	}
	return oldValue.Fork, nil
}

// ResetFork resets all changes to the "fork" field.
func (m *RepositoryMutation) ResetFork() {
	m.fork = nil
}

// SetURL sets the "url" field.
func (m *RepositoryMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *RepositoryMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *RepositoryMutation) ResetURL() {
	m.url = nil
}

// SetArchiveURL sets the "archive_url" field.
func (m *RepositoryMutation) SetArchiveURL(s string) {
	m.archive_url = &s
}

// ArchiveURL returns the value of the "archive_url" field in the mutation.
func (m *RepositoryMutation) ArchiveURL() (r string, exists bool) {
	v := m.archive_url
	if v == nil {
		return
	}
	return *v, true
}

// OldArchiveURL returns the old "archive_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldArchiveURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchiveURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchiveURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchiveURL: %w", err)
	}
	return oldValue.ArchiveURL, nil
}

// ResetArchiveURL resets all changes to the "archive_url" field.
func (m *RepositoryMutation) ResetArchiveURL() {
	m.archive_url = nil
}

// SetAssigneesURL sets the "assignees_url" field.
func (m *RepositoryMutation) SetAssigneesURL(s string) {
	m.assignees_url = &s
}

// AssigneesURL returns the value of the "assignees_url" field in the mutation.
func (m *RepositoryMutation) AssigneesURL() (r string, exists bool) {
	v := m.assignees_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneesURL returns the old "assignees_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldAssigneesURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneesURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneesURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneesURL: %w", err)
	}
	return oldValue.AssigneesURL, nil
}

// ResetAssigneesURL resets all changes to the "assignees_url" field.
func (m *RepositoryMutation) ResetAssigneesURL() {
	m.assignees_url = nil
}

// SetBlobsURL sets the "blobs_url" field.
func (m *RepositoryMutation) SetBlobsURL(s string) {
	m.blobs_url = &s
}

// BlobsURL returns the value of the "blobs_url" field in the mutation.
func (m *RepositoryMutation) BlobsURL() (r string, exists bool) {
	v := m.blobs_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBlobsURL returns the old "blobs_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldBlobsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlobsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlobsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlobsURL: %w", err)
	}
	return oldValue.BlobsURL, nil
}

// ResetBlobsURL resets all changes to the "blobs_url" field.
func (m *RepositoryMutation) ResetBlobsURL() {
	m.blobs_url = nil
}

// SetBranchesURL sets the "branches_url" field.
func (m *RepositoryMutation) SetBranchesURL(s string) {
	m.branches_url = &s
}

// BranchesURL returns the value of the "branches_url" field in the mutation.
func (m *RepositoryMutation) BranchesURL() (r string, exists bool) {
	v := m.branches_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchesURL returns the old "branches_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldBranchesURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchesURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchesURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchesURL: %w", err)
	}
	return oldValue.BranchesURL, nil
}

// ResetBranchesURL resets all changes to the "branches_url" field.
func (m *RepositoryMutation) ResetBranchesURL() {
	m.branches_url = nil
}

// SetCollaboratorsURL sets the "collaborators_url" field.
func (m *RepositoryMutation) SetCollaboratorsURL(s string) {
	m.collaborators_url = &s
}

// CollaboratorsURL returns the value of the "collaborators_url" field in the mutation.
func (m *RepositoryMutation) CollaboratorsURL() (r string, exists bool) {
	v := m.collaborators_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCollaboratorsURL returns the old "collaborators_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldCollaboratorsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollaboratorsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollaboratorsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollaboratorsURL: %w", err)
	}
	return oldValue.CollaboratorsURL, nil
}

// ResetCollaboratorsURL resets all changes to the "collaborators_url" field.
func (m *RepositoryMutation) ResetCollaboratorsURL() {
	m.collaborators_url = nil
}

// SetCommentsURL sets the "comments_url" field.
func (m *RepositoryMutation) SetCommentsURL(s string) {
	m.comments_url = &s
}

// CommentsURL returns the value of the "comments_url" field in the mutation.
func (m *RepositoryMutation) CommentsURL() (r string, exists bool) {
	v := m.comments_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentsURL returns the old "comments_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldCommentsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentsURL: %w", err)
	}
	return oldValue.CommentsURL, nil
}

// ResetCommentsURL resets all changes to the "comments_url" field.
func (m *RepositoryMutation) ResetCommentsURL() {
	m.comments_url = nil
}

// SetCommitsURL sets the "commits_url" field.
func (m *RepositoryMutation) SetCommitsURL(s string) {
	m.commits_url = &s
}

// CommitsURL returns the value of the "commits_url" field in the mutation.
func (m *RepositoryMutation) CommitsURL() (r string, exists bool) {
	v := m.commits_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitsURL returns the old "commits_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldCommitsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitsURL: %w", err)
	}
	return oldValue.CommitsURL, nil
}

// ResetCommitsURL resets all changes to the "commits_url" field.
func (m *RepositoryMutation) ResetCommitsURL() {
	m.commits_url = nil
}

// SetCompareURL sets the "compare_url" field.
func (m *RepositoryMutation) SetCompareURL(s string) {
	m.compare_url = &s
}

// CompareURL returns the value of the "compare_url" field in the mutation.
func (m *RepositoryMutation) CompareURL() (r string, exists bool) {
	v := m.compare_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCompareURL returns the old "compare_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldCompareURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompareURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompareURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompareURL: %w", err)
	}
	return oldValue.CompareURL, nil
}

// ResetCompareURL resets all changes to the "compare_url" field.
func (m *RepositoryMutation) ResetCompareURL() {
	m.compare_url = nil
}

// SetContentsURL sets the "contents_url" field.
func (m *RepositoryMutation) SetContentsURL(s string) {
	m.contents_url = &s
}

// ContentsURL returns the value of the "contents_url" field in the mutation.
func (m *RepositoryMutation) ContentsURL() (r string, exists bool) {
	v := m.contents_url
	if v == nil {
		return
	}
	return *v, true
}

// OldContentsURL returns the old "contents_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldContentsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentsURL: %w", err)
	}
	return oldValue.ContentsURL, nil
}

// ResetContentsURL resets all changes to the "contents_url" field.
func (m *RepositoryMutation) ResetContentsURL() {
	m.contents_url = nil
}

// SetContributorsURL sets the "contributors_url" field.
func (m *RepositoryMutation) SetContributorsURL(s string) {
	m.contributors_url = &s
}

// ContributorsURL returns the value of the "contributors_url" field in the mutation.
func (m *RepositoryMutation) ContributorsURL() (r string, exists bool) {
	v := m.contributors_url
	if v == nil {
		return
	}
	return *v, true
}

// OldContributorsURL returns the old "contributors_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldContributorsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContributorsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContributorsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContributorsURL: %w", err)
	}
	return oldValue.ContributorsURL, nil
}

// ResetContributorsURL resets all changes to the "contributors_url" field.
func (m *RepositoryMutation) ResetContributorsURL() {
	m.contributors_url = nil
}

// SetDeploymentsURL sets the "deployments_url" field.
func (m *RepositoryMutation) SetDeploymentsURL(s string) {
	m.deployments_url = &s
}

// DeploymentsURL returns the value of the "deployments_url" field in the mutation.
func (m *RepositoryMutation) DeploymentsURL() (r string, exists bool) {
	v := m.deployments_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentsURL returns the old "deployments_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDeploymentsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentsURL: %w", err)
	}
	return oldValue.DeploymentsURL, nil
}

// ResetDeploymentsURL resets all changes to the "deployments_url" field.
func (m *RepositoryMutation) ResetDeploymentsURL() {
	m.deployments_url = nil
}

// SetDownloadsURL sets the "downloads_url" field.
func (m *RepositoryMutation) SetDownloadsURL(s string) {
	m.downloads_url = &s
}

// DownloadsURL returns the value of the "downloads_url" field in the mutation.
func (m *RepositoryMutation) DownloadsURL() (r string, exists bool) {
	v := m.downloads_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadsURL returns the old "downloads_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDownloadsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadsURL: %w", err)
	}
	return oldValue.DownloadsURL, nil
}

// ResetDownloadsURL resets all changes to the "downloads_url" field.
func (m *RepositoryMutation) ResetDownloadsURL() {
	m.downloads_url = nil
}

// SetEventsURL sets the "events_url" field.
func (m *RepositoryMutation) SetEventsURL(s string) {
	m.events_url = &s
}

// EventsURL returns the value of the "events_url" field in the mutation.
func (m *RepositoryMutation) EventsURL() (r string, exists bool) {
	v := m.events_url
	if v == nil {
		return
	}
	return *v, true
}

// OldEventsURL returns the old "events_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldEventsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventsURL: %w", err)
	}
	return oldValue.EventsURL, nil
}

// ResetEventsURL resets all changes to the "events_url" field.
func (m *RepositoryMutation) ResetEventsURL() {
	m.events_url = nil
}

// SetForksURL sets the "forks_url" field.
func (m *RepositoryMutation) SetForksURL(s string) {
	m.forks_url = &s
}

// ForksURL returns the value of the "forks_url" field in the mutation.
func (m *RepositoryMutation) ForksURL() (r string, exists bool) {
	v := m.forks_url
	if v == nil {
		return
	}
	return *v, true
}

// OldForksURL returns the old "forks_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldForksURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForksURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForksURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForksURL: %w", err)
	}
	return oldValue.ForksURL, nil
}

// ResetForksURL resets all changes to the "forks_url" field.
func (m *RepositoryMutation) ResetForksURL() {
	m.forks_url = nil
}

// SetGitCommitsURL sets the "git_commits_url" field.
func (m *RepositoryMutation) SetGitCommitsURL(s string) {
	m.git_commits_url = &s
}

// GitCommitsURL returns the value of the "git_commits_url" field in the mutation.
func (m *RepositoryMutation) GitCommitsURL() (r string, exists bool) {
	v := m.git_commits_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitsURL returns the old "git_commits_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldGitCommitsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitsURL: %w", err)
	}
	return oldValue.GitCommitsURL, nil
}

// ResetGitCommitsURL resets all changes to the "git_commits_url" field.
func (m *RepositoryMutation) ResetGitCommitsURL() {
	m.git_commits_url = nil
}

// SetGitRefsURL sets the "git_refs_url" field.
func (m *RepositoryMutation) SetGitRefsURL(s string) {
	m.git_refs_url = &s
}

// GitRefsURL returns the value of the "git_refs_url" field in the mutation.
func (m *RepositoryMutation) GitRefsURL() (r string, exists bool) {
	v := m.git_refs_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitRefsURL returns the old "git_refs_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldGitRefsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitRefsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitRefsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitRefsURL: %w", err)
	}
	return oldValue.GitRefsURL, nil
}

// ResetGitRefsURL resets all changes to the "git_refs_url" field.
func (m *RepositoryMutation) ResetGitRefsURL() {
	m.git_refs_url = nil
}

// SetGitTagsURL sets the "git_tags_url" field.
func (m *RepositoryMutation) SetGitTagsURL(s string) {
	m.git_tags_url = &s
}

// GitTagsURL returns the value of the "git_tags_url" field in the mutation.
func (m *RepositoryMutation) GitTagsURL() (r string, exists bool) {
	v := m.git_tags_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitTagsURL returns the old "git_tags_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldGitTagsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitTagsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitTagsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitTagsURL: %w", err)
	}
	return oldValue.GitTagsURL, nil
}

// ResetGitTagsURL resets all changes to the "git_tags_url" field.
func (m *RepositoryMutation) ResetGitTagsURL() {
	m.git_tags_url = nil
}

// SetGitURL sets the "git_url" field.
func (m *RepositoryMutation) SetGitURL(s string) {
	m.git_url = &s
}

// GitURL returns the value of the "git_url" field in the mutation.
func (m *RepositoryMutation) GitURL() (r string, exists bool) {
	v := m.git_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitURL returns the old "git_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldGitURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitURL: %w", err)
	}
	return oldValue.GitURL, nil
}

// ResetGitURL resets all changes to the "git_url" field.
func (m *RepositoryMutation) ResetGitURL() {
	m.git_url = nil
}

// SetIssueCommentURL sets the "issue_comment_url" field.
func (m *RepositoryMutation) SetIssueCommentURL(s string) {
	m.issue_comment_url = &s
}

// IssueCommentURL returns the value of the "issue_comment_url" field in the mutation.
func (m *RepositoryMutation) IssueCommentURL() (r string, exists bool) {
	v := m.issue_comment_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueCommentURL returns the old "issue_comment_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldIssueCommentURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueCommentURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueCommentURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueCommentURL: %w", err)
	}
	return oldValue.IssueCommentURL, nil
}

// ResetIssueCommentURL resets all changes to the "issue_comment_url" field.
func (m *RepositoryMutation) ResetIssueCommentURL() {
	m.issue_comment_url = nil
}

// SetIssueEventsURL sets the "issue_events_url" field.
func (m *RepositoryMutation) SetIssueEventsURL(s string) {
	m.issue_events_url = &s
}

// IssueEventsURL returns the value of the "issue_events_url" field in the mutation.
func (m *RepositoryMutation) IssueEventsURL() (r string, exists bool) {
	v := m.issue_events_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIssueEventsURL returns the old "issue_events_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldIssueEventsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssueEventsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssueEventsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssueEventsURL: %w", err)
	}
	return oldValue.IssueEventsURL, nil
}

// ResetIssueEventsURL resets all changes to the "issue_events_url" field.
func (m *RepositoryMutation) ResetIssueEventsURL() {
	m.issue_events_url = nil
}

// SetIssuesURL sets the "issues_url" field.
func (m *RepositoryMutation) SetIssuesURL(s string) {
	m.issues_url = &s
}

// IssuesURL returns the value of the "issues_url" field in the mutation.
func (m *RepositoryMutation) IssuesURL() (r string, exists bool) {
	v := m.issues_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuesURL returns the old "issues_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldIssuesURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuesURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuesURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuesURL: %w", err)
	}
	return oldValue.IssuesURL, nil
}

// ResetIssuesURL resets all changes to the "issues_url" field.
func (m *RepositoryMutation) ResetIssuesURL() {
	m.issues_url = nil
}

// SetKeysURL sets the "keys_url" field.
func (m *RepositoryMutation) SetKeysURL(s string) {
	m.keys_url = &s
}

// KeysURL returns the value of the "keys_url" field in the mutation.
func (m *RepositoryMutation) KeysURL() (r string, exists bool) {
	v := m.keys_url
	if v == nil {
		return
	}
	return *v, true
}

// OldKeysURL returns the old "keys_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldKeysURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeysURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeysURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeysURL: %w", err)
	}
	return oldValue.KeysURL, nil
}

// ResetKeysURL resets all changes to the "keys_url" field.
func (m *RepositoryMutation) ResetKeysURL() {
	m.keys_url = nil
}

// SetLabelsURL sets the "labels_url" field.
func (m *RepositoryMutation) SetLabelsURL(s string) {
	m.labels_url = &s
}

// LabelsURL returns the value of the "labels_url" field in the mutation.
func (m *RepositoryMutation) LabelsURL() (r string, exists bool) {
	v := m.labels_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelsURL returns the old "labels_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldLabelsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelsURL: %w", err)
	}
	return oldValue.LabelsURL, nil
}

// ResetLabelsURL resets all changes to the "labels_url" field.
func (m *RepositoryMutation) ResetLabelsURL() {
	m.labels_url = nil
}

// SetLanguagesURL sets the "languages_url" field.
func (m *RepositoryMutation) SetLanguagesURL(s string) {
	m.languages_url = &s
}

// LanguagesURL returns the value of the "languages_url" field in the mutation.
func (m *RepositoryMutation) LanguagesURL() (r string, exists bool) {
	v := m.languages_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguagesURL returns the old "languages_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldLanguagesURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguagesURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguagesURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguagesURL: %w", err)
	}
	return oldValue.LanguagesURL, nil
}

// ResetLanguagesURL resets all changes to the "languages_url" field.
func (m *RepositoryMutation) ResetLanguagesURL() {
	m.languages_url = nil
}

// SetMergesURL sets the "merges_url" field.
func (m *RepositoryMutation) SetMergesURL(s string) {
	m.merges_url = &s
}

// MergesURL returns the value of the "merges_url" field in the mutation.
func (m *RepositoryMutation) MergesURL() (r string, exists bool) {
	v := m.merges_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMergesURL returns the old "merges_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldMergesURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMergesURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMergesURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMergesURL: %w", err)
	}
	return oldValue.MergesURL, nil
}

// ResetMergesURL resets all changes to the "merges_url" field.
func (m *RepositoryMutation) ResetMergesURL() {
	m.merges_url = nil
}

// SetMilestonesURL sets the "milestones_url" field.
func (m *RepositoryMutation) SetMilestonesURL(s string) {
	m.milestones_url = &s
}

// MilestonesURL returns the value of the "milestones_url" field in the mutation.
func (m *RepositoryMutation) MilestonesURL() (r string, exists bool) {
	v := m.milestones_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMilestonesURL returns the old "milestones_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldMilestonesURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMilestonesURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMilestonesURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMilestonesURL: %w", err)
	}
	return oldValue.MilestonesURL, nil
}

// ResetMilestonesURL resets all changes to the "milestones_url" field.
func (m *RepositoryMutation) ResetMilestonesURL() {
	m.milestones_url = nil
}

// SetNotificationsURL sets the "notifications_url" field.
func (m *RepositoryMutation) SetNotificationsURL(s string) {
	m.notifications_url = &s
}

// NotificationsURL returns the value of the "notifications_url" field in the mutation.
func (m *RepositoryMutation) NotificationsURL() (r string, exists bool) {
	v := m.notifications_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationsURL returns the old "notifications_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldNotificationsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationsURL: %w", err)
	}
	return oldValue.NotificationsURL, nil
}

// ResetNotificationsURL resets all changes to the "notifications_url" field.
func (m *RepositoryMutation) ResetNotificationsURL() {
	m.notifications_url = nil
}

// SetPullsURL sets the "pulls_url" field.
func (m *RepositoryMutation) SetPullsURL(s string) {
	m.pulls_url = &s
}

// PullsURL returns the value of the "pulls_url" field in the mutation.
func (m *RepositoryMutation) PullsURL() (r string, exists bool) {
	v := m.pulls_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPullsURL returns the old "pulls_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldPullsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullsURL: %w", err)
	}
	return oldValue.PullsURL, nil
}

// ResetPullsURL resets all changes to the "pulls_url" field.
func (m *RepositoryMutation) ResetPullsURL() {
	m.pulls_url = nil
}

// SetReleasesURL sets the "releases_url" field.
func (m *RepositoryMutation) SetReleasesURL(s string) {
	m.releases_url = &s
}

// ReleasesURL returns the value of the "releases_url" field in the mutation.
func (m *RepositoryMutation) ReleasesURL() (r string, exists bool) {
	v := m.releases_url
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasesURL returns the old "releases_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldReleasesURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasesURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasesURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasesURL: %w", err)
	}
	return oldValue.ReleasesURL, nil
}

// ResetReleasesURL resets all changes to the "releases_url" field.
func (m *RepositoryMutation) ResetReleasesURL() {
	m.releases_url = nil
}

// SetSSHURL sets the "ssh_url" field.
func (m *RepositoryMutation) SetSSHURL(s string) {
	m.ssh_url = &s
}

// SSHURL returns the value of the "ssh_url" field in the mutation.
func (m *RepositoryMutation) SSHURL() (r string, exists bool) {
	v := m.ssh_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSSHURL returns the old "ssh_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldSSHURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSHURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSHURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSHURL: %w", err)
	}
	return oldValue.SSHURL, nil
}

// ResetSSHURL resets all changes to the "ssh_url" field.
func (m *RepositoryMutation) ResetSSHURL() {
	m.ssh_url = nil
}

// SetStargazersURL sets the "stargazers_url" field.
func (m *RepositoryMutation) SetStargazersURL(s string) {
	m.stargazers_url = &s
}

// StargazersURL returns the value of the "stargazers_url" field in the mutation.
func (m *RepositoryMutation) StargazersURL() (r string, exists bool) {
	v := m.stargazers_url
	if v == nil {
		return
	}
	return *v, true
}

// OldStargazersURL returns the old "stargazers_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldStargazersURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStargazersURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStargazersURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStargazersURL: %w", err)
	}
	return oldValue.StargazersURL, nil
}

// ResetStargazersURL resets all changes to the "stargazers_url" field.
func (m *RepositoryMutation) ResetStargazersURL() {
	m.stargazers_url = nil
}

// SetStatusesURL sets the "statuses_url" field.
func (m *RepositoryMutation) SetStatusesURL(s string) {
	m.statuses_url = &s
}

// StatusesURL returns the value of the "statuses_url" field in the mutation.
func (m *RepositoryMutation) StatusesURL() (r string, exists bool) {
	v := m.statuses_url
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusesURL returns the old "statuses_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldStatusesURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusesURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusesURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusesURL: %w", err)
	}
	return oldValue.StatusesURL, nil
}

// ResetStatusesURL resets all changes to the "statuses_url" field.
func (m *RepositoryMutation) ResetStatusesURL() {
	m.statuses_url = nil
}

// SetSubscribersURL sets the "subscribers_url" field.
func (m *RepositoryMutation) SetSubscribersURL(s string) {
	m.subscribers_url = &s
}

// SubscribersURL returns the value of the "subscribers_url" field in the mutation.
func (m *RepositoryMutation) SubscribersURL() (r string, exists bool) {
	v := m.subscribers_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribersURL returns the old "subscribers_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldSubscribersURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribersURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribersURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribersURL: %w", err)
	}
	return oldValue.SubscribersURL, nil
}

// ResetSubscribersURL resets all changes to the "subscribers_url" field.
func (m *RepositoryMutation) ResetSubscribersURL() {
	m.subscribers_url = nil
}

// SetSubscriptionURL sets the "subscription_url" field.
func (m *RepositoryMutation) SetSubscriptionURL(s string) {
	m.subscription_url = &s
}

// SubscriptionURL returns the value of the "subscription_url" field in the mutation.
func (m *RepositoryMutation) SubscriptionURL() (r string, exists bool) {
	v := m.subscription_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionURL returns the old "subscription_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldSubscriptionURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionURL: %w", err)
	}
	return oldValue.SubscriptionURL, nil
}

// ResetSubscriptionURL resets all changes to the "subscription_url" field.
func (m *RepositoryMutation) ResetSubscriptionURL() {
	m.subscription_url = nil
}

// SetTagsURL sets the "tags_url" field.
func (m *RepositoryMutation) SetTagsURL(s string) {
	m.tags_url = &s
}

// TagsURL returns the value of the "tags_url" field in the mutation.
func (m *RepositoryMutation) TagsURL() (r string, exists bool) {
	v := m.tags_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTagsURL returns the old "tags_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldTagsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagsURL: %w", err)
	}
	return oldValue.TagsURL, nil
}

// ResetTagsURL resets all changes to the "tags_url" field.
func (m *RepositoryMutation) ResetTagsURL() {
	m.tags_url = nil
}

// SetTeamsURL sets the "teams_url" field.
func (m *RepositoryMutation) SetTeamsURL(s string) {
	m.teams_url = &s
}

// TeamsURL returns the value of the "teams_url" field in the mutation.
func (m *RepositoryMutation) TeamsURL() (r string, exists bool) {
	v := m.teams_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamsURL returns the old "teams_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldTeamsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamsURL: %w", err)
	}
	return oldValue.TeamsURL, nil
}

// ResetTeamsURL resets all changes to the "teams_url" field.
func (m *RepositoryMutation) ResetTeamsURL() {
	m.teams_url = nil
}

// SetTreesURL sets the "trees_url" field.
func (m *RepositoryMutation) SetTreesURL(s string) {
	m.trees_url = &s
}

// TreesURL returns the value of the "trees_url" field in the mutation.
func (m *RepositoryMutation) TreesURL() (r string, exists bool) {
	v := m.trees_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTreesURL returns the old "trees_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldTreesURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTreesURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTreesURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreesURL: %w", err)
	}
	return oldValue.TreesURL, nil
}

// ResetTreesURL resets all changes to the "trees_url" field.
func (m *RepositoryMutation) ResetTreesURL() {
	m.trees_url = nil
}

// SetCloneURL sets the "clone_url" field.
func (m *RepositoryMutation) SetCloneURL(s string) {
	m.clone_url = &s
}

// CloneURL returns the value of the "clone_url" field in the mutation.
func (m *RepositoryMutation) CloneURL() (r string, exists bool) {
	v := m.clone_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCloneURL returns the old "clone_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldCloneURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloneURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloneURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloneURL: %w", err)
	}
	return oldValue.CloneURL, nil
}

// ResetCloneURL resets all changes to the "clone_url" field.
func (m *RepositoryMutation) ResetCloneURL() {
	m.clone_url = nil
}

// SetMirrorURL sets the "mirror_url" field.
func (m *RepositoryMutation) SetMirrorURL(s string) {
	m.mirror_url = &s
}

// MirrorURL returns the value of the "mirror_url" field in the mutation.
func (m *RepositoryMutation) MirrorURL() (r string, exists bool) {
	v := m.mirror_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMirrorURL returns the old "mirror_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldMirrorURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMirrorURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMirrorURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMirrorURL: %w", err)
	}
	return oldValue.MirrorURL, nil
}

// ClearMirrorURL clears the value of the "mirror_url" field.
func (m *RepositoryMutation) ClearMirrorURL() {
	m.mirror_url = nil
	m.clearedFields[repository.FieldMirrorURL] = struct{}{}
}

// MirrorURLCleared returns if the "mirror_url" field was cleared in this mutation.
func (m *RepositoryMutation) MirrorURLCleared() bool {
	_, ok := m.clearedFields[repository.FieldMirrorURL]
	return ok
}

// ResetMirrorURL resets all changes to the "mirror_url" field.
func (m *RepositoryMutation) ResetMirrorURL() {
	m.mirror_url = nil
	delete(m.clearedFields, repository.FieldMirrorURL)
}

// SetHooksURL sets the "hooks_url" field.
func (m *RepositoryMutation) SetHooksURL(s string) {
	m.hooks_url = &s
}

// HooksURL returns the value of the "hooks_url" field in the mutation.
func (m *RepositoryMutation) HooksURL() (r string, exists bool) {
	v := m.hooks_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHooksURL returns the old "hooks_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHooksURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHooksURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHooksURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHooksURL: %w", err)
	}
	return oldValue.HooksURL, nil
}

// ResetHooksURL resets all changes to the "hooks_url" field.
func (m *RepositoryMutation) ResetHooksURL() {
	m.hooks_url = nil
}

// SetSvnURL sets the "svn_url" field.
func (m *RepositoryMutation) SetSvnURL(s string) {
	m.svn_url = &s
}

// SvnURL returns the value of the "svn_url" field in the mutation.
func (m *RepositoryMutation) SvnURL() (r string, exists bool) {
	v := m.svn_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSvnURL returns the old "svn_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldSvnURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSvnURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSvnURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSvnURL: %w", err)
	}
	return oldValue.SvnURL, nil
}

// ResetSvnURL resets all changes to the "svn_url" field.
func (m *RepositoryMutation) ResetSvnURL() {
	m.svn_url = nil
}

// SetHomepage sets the "homepage" field.
func (m *RepositoryMutation) SetHomepage(s string) {
	m.homepage = &s
}

// Homepage returns the value of the "homepage" field in the mutation.
func (m *RepositoryMutation) Homepage() (r string, exists bool) {
	v := m.homepage
	if v == nil {
		return
	}
	return *v, true
}

// OldHomepage returns the old "homepage" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHomepage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomepage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomepage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomepage: %w", err)
	}
	return oldValue.Homepage, nil
}

// ClearHomepage clears the value of the "homepage" field.
func (m *RepositoryMutation) ClearHomepage() {
	m.homepage = nil
	m.clearedFields[repository.FieldHomepage] = struct{}{}
}

// HomepageCleared returns if the "homepage" field was cleared in this mutation.
func (m *RepositoryMutation) HomepageCleared() bool {
	_, ok := m.clearedFields[repository.FieldHomepage]
	return ok
}

// ResetHomepage resets all changes to the "homepage" field.
func (m *RepositoryMutation) ResetHomepage() {
	m.homepage = nil
	delete(m.clearedFields, repository.FieldHomepage)
}

// SetLanguage sets the "language" field.
func (m *RepositoryMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *RepositoryMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *RepositoryMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[repository.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *RepositoryMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[repository.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *RepositoryMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, repository.FieldLanguage)
}

// SetForksCount sets the "forks_count" field.
func (m *RepositoryMutation) SetForksCount(i int64) {
	m.forks_count = &i
	m.addforks_count = nil
}

// ForksCount returns the value of the "forks_count" field in the mutation.
func (m *RepositoryMutation) ForksCount() (r int64, exists bool) {
	v := m.forks_count
	if v == nil {
		return
	}
	return *v, true
}

// OldForksCount returns the old "forks_count" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldForksCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForksCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForksCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForksCount: %w", err)
	}
	return oldValue.ForksCount, nil
}

// AddForksCount adds i to the "forks_count" field.
func (m *RepositoryMutation) AddForksCount(i int64) {
	if m.addforks_count != nil {
		*m.addforks_count += i
	} else {
		m.addforks_count = &i
	}
}

// AddedForksCount returns the value that was added to the "forks_count" field in this mutation.
func (m *RepositoryMutation) AddedForksCount() (r int64, exists bool) {
	v := m.addforks_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetForksCount resets all changes to the "forks_count" field.
func (m *RepositoryMutation) ResetForksCount() {
	m.forks_count = nil
	m.addforks_count = nil
}

// SetStargazersCount sets the "stargazers_count" field.
func (m *RepositoryMutation) SetStargazersCount(i int64) {
	m.stargazers_count = &i
	m.addstargazers_count = nil
}

// StargazersCount returns the value of the "stargazers_count" field in the mutation.
func (m *RepositoryMutation) StargazersCount() (r int64, exists bool) {
	v := m.stargazers_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStargazersCount returns the old "stargazers_count" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldStargazersCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStargazersCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStargazersCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStargazersCount: %w", err)
	}
	return oldValue.StargazersCount, nil
}

// AddStargazersCount adds i to the "stargazers_count" field.
func (m *RepositoryMutation) AddStargazersCount(i int64) {
	if m.addstargazers_count != nil {
		*m.addstargazers_count += i
	} else {
		m.addstargazers_count = &i
	}
}

// AddedStargazersCount returns the value that was added to the "stargazers_count" field in this mutation.
func (m *RepositoryMutation) AddedStargazersCount() (r int64, exists bool) {
	v := m.addstargazers_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStargazersCount resets all changes to the "stargazers_count" field.
func (m *RepositoryMutation) ResetStargazersCount() {
	m.stargazers_count = nil
	m.addstargazers_count = nil
}

// SetWatchersCount sets the "watchers_count" field.
func (m *RepositoryMutation) SetWatchersCount(i int64) {
	m.watchers_count = &i
	m.addwatchers_count = nil
}

// WatchersCount returns the value of the "watchers_count" field in the mutation.
func (m *RepositoryMutation) WatchersCount() (r int64, exists bool) {
	v := m.watchers_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWatchersCount returns the old "watchers_count" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldWatchersCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWatchersCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWatchersCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatchersCount: %w", err)
	}
	return oldValue.WatchersCount, nil
}

// AddWatchersCount adds i to the "watchers_count" field.
func (m *RepositoryMutation) AddWatchersCount(i int64) {
	if m.addwatchers_count != nil {
		*m.addwatchers_count += i
	} else {
		m.addwatchers_count = &i
	}
}

// AddedWatchersCount returns the value that was added to the "watchers_count" field in this mutation.
func (m *RepositoryMutation) AddedWatchersCount() (r int64, exists bool) {
	v := m.addwatchers_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWatchersCount resets all changes to the "watchers_count" field.
func (m *RepositoryMutation) ResetWatchersCount() {
	m.watchers_count = nil
	m.addwatchers_count = nil
}

// SetSize sets the "size" field.
func (m *RepositoryMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *RepositoryMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *RepositoryMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *RepositoryMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *RepositoryMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetDefaultBranch sets the "default_branch" field.
func (m *RepositoryMutation) SetDefaultBranch(s string) {
	m.default_branch = &s
}

// DefaultBranch returns the value of the "default_branch" field in the mutation.
func (m *RepositoryMutation) DefaultBranch() (r string, exists bool) {
	v := m.default_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultBranch returns the old "default_branch" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDefaultBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultBranch: %w", err)
	}
	return oldValue.DefaultBranch, nil
}

// ResetDefaultBranch resets all changes to the "default_branch" field.
func (m *RepositoryMutation) ResetDefaultBranch() {
	m.default_branch = nil
}

// SetOpenIssuesCount sets the "open_issues_count" field.
func (m *RepositoryMutation) SetOpenIssuesCount(i int64) {
	m.open_issues_count = &i
	m.addopen_issues_count = nil
}

// OpenIssuesCount returns the value of the "open_issues_count" field in the mutation.
func (m *RepositoryMutation) OpenIssuesCount() (r int64, exists bool) {
	v := m.open_issues_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenIssuesCount returns the old "open_issues_count" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldOpenIssuesCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenIssuesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenIssuesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenIssuesCount: %w", err)
	}
	return oldValue.OpenIssuesCount, nil
}

// AddOpenIssuesCount adds i to the "open_issues_count" field.
func (m *RepositoryMutation) AddOpenIssuesCount(i int64) {
	if m.addopen_issues_count != nil {
		*m.addopen_issues_count += i
	} else {
		m.addopen_issues_count = &i
	}
}

// AddedOpenIssuesCount returns the value that was added to the "open_issues_count" field in this mutation.
func (m *RepositoryMutation) AddedOpenIssuesCount() (r int64, exists bool) {
	v := m.addopen_issues_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpenIssuesCount resets all changes to the "open_issues_count" field.
func (m *RepositoryMutation) ResetOpenIssuesCount() {
	m.open_issues_count = nil
	m.addopen_issues_count = nil
}

// SetIsTemplate sets the "is_template" field.
func (m *RepositoryMutation) SetIsTemplate(b bool) {
	m.is_template = &b
}

// IsTemplate returns the value of the "is_template" field in the mutation.
func (m *RepositoryMutation) IsTemplate() (r bool, exists bool) {
	v := m.is_template
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTemplate returns the old "is_template" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldIsTemplate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTemplate: %w", err)
	}
	return oldValue.IsTemplate, nil
}

// ResetIsTemplate resets all changes to the "is_template" field.
func (m *RepositoryMutation) ResetIsTemplate() {
	m.is_template = nil
}

// SetTopics sets the "topics" field.
func (m *RepositoryMutation) SetTopics(s []string) {
	m.topics = &s
	m.appendtopics = nil
}

// Topics returns the value of the "topics" field in the mutation.
func (m *RepositoryMutation) Topics() (r []string, exists bool) {
	v := m.topics
	if v == nil {
		return
	}
	return *v, true
}

// OldTopics returns the old "topics" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldTopics(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopics: %w", err)
	}
	return oldValue.Topics, nil
}

// AppendTopics adds s to the "topics" field.
func (m *RepositoryMutation) AppendTopics(s []string) {
	m.appendtopics = append(m.appendtopics, s...)
}

// AppendedTopics returns the list of values that were appended to the "topics" field in this mutation.
func (m *RepositoryMutation) AppendedTopics() ([]string, bool) {
	if len(m.appendtopics) == 0 {
		return nil, false
	}
	return m.appendtopics, true
}

// ResetTopics resets all changes to the "topics" field.
func (m *RepositoryMutation) ResetTopics() {
	m.topics = nil
	m.appendtopics = nil
}

// SetHasIssuesEnabled sets the "has_issues_enabled" field.
func (m *RepositoryMutation) SetHasIssuesEnabled(b bool) {
	m.has_issues_enabled = &b
}

// HasIssuesEnabled returns the value of the "has_issues_enabled" field in the mutation.
func (m *RepositoryMutation) HasIssuesEnabled() (r bool, exists bool) {
	v := m.has_issues_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldHasIssuesEnabled returns the old "has_issues_enabled" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHasIssuesEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasIssuesEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasIssuesEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasIssuesEnabled: %w", err)
	}
	return oldValue.HasIssuesEnabled, nil
}

// ResetHasIssuesEnabled resets all changes to the "has_issues_enabled" field.
func (m *RepositoryMutation) ResetHasIssuesEnabled() {
	m.has_issues_enabled = nil
}

// SetHasProjects sets the "has_projects" field.
func (m *RepositoryMutation) SetHasProjects(b bool) {
	m.has_projects = &b
}

// HasProjects returns the value of the "has_projects" field in the mutation.
func (m *RepositoryMutation) HasProjects() (r bool, exists bool) {
	v := m.has_projects
	if v == nil {
		return
	}
	return *v, true
}

// OldHasProjects returns the old "has_projects" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHasProjects(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasProjects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasProjects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasProjects: %w", err)
	}
	return oldValue.HasProjects, nil
}

// ResetHasProjects resets all changes to the "has_projects" field.
func (m *RepositoryMutation) ResetHasProjects() {
	m.has_projects = nil
}

// SetHasWiki sets the "has_wiki" field.
func (m *RepositoryMutation) SetHasWiki(b bool) {
	m.has_wiki = &b
}

// HasWiki returns the value of the "has_wiki" field in the mutation.
func (m *RepositoryMutation) HasWiki() (r bool, exists bool) {
	v := m.has_wiki
	if v == nil {
		return
	}
	return *v, true
}

// OldHasWiki returns the old "has_wiki" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHasWiki(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasWiki is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasWiki requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasWiki: %w", err)
	}
	return oldValue.HasWiki, nil
}

// ResetHasWiki resets all changes to the "has_wiki" field.
func (m *RepositoryMutation) ResetHasWiki() {
	m.has_wiki = nil
}

// SetHasPages sets the "has_pages" field.
func (m *RepositoryMutation) SetHasPages(b bool) {
	m.has_pages = &b
}

// HasPages returns the value of the "has_pages" field in the mutation.
func (m *RepositoryMutation) HasPages() (r bool, exists bool) {
	v := m.has_pages
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPages returns the old "has_pages" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHasPages(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasPages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasPages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPages: %w", err)
	}
	return oldValue.HasPages, nil
}

// ResetHasPages resets all changes to the "has_pages" field.
func (m *RepositoryMutation) ResetHasPages() {
	m.has_pages = nil
}

// SetHasDownloads sets the "has_downloads" field.
func (m *RepositoryMutation) SetHasDownloads(b bool) {
	m.has_downloads = &b
}

// HasDownloads returns the value of the "has_downloads" field in the mutation.
func (m *RepositoryMutation) HasDownloads() (r bool, exists bool) {
	v := m.has_downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldHasDownloads returns the old "has_downloads" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHasDownloads(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasDownloads: %w", err)
	}
	return oldValue.HasDownloads, nil
}

// ResetHasDownloads resets all changes to the "has_downloads" field.
func (m *RepositoryMutation) ResetHasDownloads() {
	m.has_downloads = nil
}

// SetHasDiscussions sets the "has_discussions" field.
func (m *RepositoryMutation) SetHasDiscussions(b bool) {
	m.has_discussions = &b
}

// HasDiscussions returns the value of the "has_discussions" field in the mutation.
func (m *RepositoryMutation) HasDiscussions() (r bool, exists bool) {
	v := m.has_discussions
	if v == nil {
		return
	}
	return *v, true
}

// OldHasDiscussions returns the old "has_discussions" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldHasDiscussions(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasDiscussions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasDiscussions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasDiscussions: %w", err)
	}
	return oldValue.HasDiscussions, nil
}

// ResetHasDiscussions resets all changes to the "has_discussions" field.
func (m *RepositoryMutation) ResetHasDiscussions() {
	m.has_discussions = nil
}

// SetArchived sets the "archived" field.
func (m *RepositoryMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *RepositoryMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *RepositoryMutation) ResetArchived() {
	m.archived = nil
}

// SetDisabled sets the "disabled" field.
func (m *RepositoryMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *RepositoryMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *RepositoryMutation) ResetDisabled() {
	m.disabled = nil
}

// SetVisibility sets the "visibility" field.
func (m *RepositoryMutation) SetVisibility(r repository.Visibility) {
	m.visibility = &r
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *RepositoryMutation) Visibility() (r repository.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldVisibility(ctx context.Context) (v *repository.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ClearVisibility clears the value of the "visibility" field.
func (m *RepositoryMutation) ClearVisibility() {
	m.visibility = nil
	m.clearedFields[repository.FieldVisibility] = struct{}{}
}

// VisibilityCleared returns if the "visibility" field was cleared in this mutation.
func (m *RepositoryMutation) VisibilityCleared() bool {
	_, ok := m.clearedFields[repository.FieldVisibility]
	return ok
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *RepositoryMutation) ResetVisibility() {
	m.visibility = nil
	delete(m.clearedFields, repository.FieldVisibility)
}

// SetPushedAt sets the "pushed_at" field.
func (m *RepositoryMutation) SetPushedAt(t time.Time) {
	m.pushed_at = &t
}

// PushedAt returns the value of the "pushed_at" field in the mutation.
func (m *RepositoryMutation) PushedAt() (r time.Time, exists bool) {
	v := m.pushed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPushedAt returns the old "pushed_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldPushedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushedAt: %w", err)
	}
	return oldValue.PushedAt, nil
}

// ResetPushedAt resets all changes to the "pushed_at" field.
func (m *RepositoryMutation) ResetPushedAt() {
	m.pushed_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RepositoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RepositoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RepositoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RepositoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RepositoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RepositoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSubscribersCount sets the "subscribers_count" field.
func (m *RepositoryMutation) SetSubscribersCount(i int64) {
	m.subscribers_count = &i
	m.addsubscribers_count = nil
}

// SubscribersCount returns the value of the "subscribers_count" field in the mutation.
func (m *RepositoryMutation) SubscribersCount() (r int64, exists bool) {
	v := m.subscribers_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribersCount returns the old "subscribers_count" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldSubscribersCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribersCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribersCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribersCount: %w", err)
	}
	return oldValue.SubscribersCount, nil
}

// AddSubscribersCount adds i to the "subscribers_count" field.
func (m *RepositoryMutation) AddSubscribersCount(i int64) {
	if m.addsubscribers_count != nil {
		*m.addsubscribers_count += i
	} else {
		m.addsubscribers_count = &i
	}
}

// AddedSubscribersCount returns the value that was added to the "subscribers_count" field in this mutation.
func (m *RepositoryMutation) AddedSubscribersCount() (r int64, exists bool) {
	v := m.addsubscribers_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubscribersCount resets all changes to the "subscribers_count" field.
func (m *RepositoryMutation) ResetSubscribersCount() {
	m.subscribers_count = nil
	m.addsubscribers_count = nil
}

// SetNetworkCount sets the "network_count" field.
func (m *RepositoryMutation) SetNetworkCount(i int64) {
	m.network_count = &i
	m.addnetwork_count = nil
}

// NetworkCount returns the value of the "network_count" field in the mutation.
func (m *RepositoryMutation) NetworkCount() (r int64, exists bool) {
	v := m.network_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkCount returns the old "network_count" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldNetworkCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetworkCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetworkCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkCount: %w", err)
	}
	return oldValue.NetworkCount, nil
}

// AddNetworkCount adds i to the "network_count" field.
func (m *RepositoryMutation) AddNetworkCount(i int64) {
	if m.addnetwork_count != nil {
		*m.addnetwork_count += i
	} else {
		m.addnetwork_count = &i
	}
}

// AddedNetworkCount returns the value that was added to the "network_count" field in this mutation.
func (m *RepositoryMutation) AddedNetworkCount() (r int64, exists bool) {
	v := m.addnetwork_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetworkCount resets all changes to the "network_count" field.
func (m *RepositoryMutation) ResetNetworkCount() {
	m.network_count = nil
	m.addnetwork_count = nil
}

// SetForks sets the "forks" field.
func (m *RepositoryMutation) SetForks(i int64) {
	m.forks = &i
	m.addforks = nil
}

// Forks returns the value of the "forks" field in the mutation.
func (m *RepositoryMutation) Forks() (r int64, exists bool) {
	v := m.forks
	if v == nil {
		return
	}
	return *v, true
}

// OldForks returns the old "forks" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldForks(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForks: %w", err)
	}
	return oldValue.Forks, nil
}

// AddForks adds i to the "forks" field.
func (m *RepositoryMutation) AddForks(i int64) {
	if m.addforks != nil {
		*m.addforks += i
	} else {
		m.addforks = &i
	}
}

// AddedForks returns the value that was added to the "forks" field in this mutation.
func (m *RepositoryMutation) AddedForks() (r int64, exists bool) {
	v := m.addforks
	if v == nil {
		return
	}
	return *v, true
}

// ResetForks resets all changes to the "forks" field.
func (m *RepositoryMutation) ResetForks() {
	m.forks = nil
	m.addforks = nil
}

// SetOpenIssues sets the "open_issues" field.
func (m *RepositoryMutation) SetOpenIssues(i int64) {
	m.open_issues = &i
	m.addopen_issues = nil
}

// OpenIssues returns the value of the "open_issues" field in the mutation.
func (m *RepositoryMutation) OpenIssues() (r int64, exists bool) {
	v := m.open_issues
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenIssues returns the old "open_issues" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldOpenIssues(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenIssues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenIssues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenIssues: %w", err)
	}
	return oldValue.OpenIssues, nil
}

// AddOpenIssues adds i to the "open_issues" field.
func (m *RepositoryMutation) AddOpenIssues(i int64) {
	if m.addopen_issues != nil {
		*m.addopen_issues += i
	} else {
		m.addopen_issues = &i
	}
}

// AddedOpenIssues returns the value that was added to the "open_issues" field in this mutation.
func (m *RepositoryMutation) AddedOpenIssues() (r int64, exists bool) {
	v := m.addopen_issues
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpenIssues resets all changes to the "open_issues" field.
func (m *RepositoryMutation) ResetOpenIssues() {
	m.open_issues = nil
	m.addopen_issues = nil
}

// SetWatchers sets the "watchers" field.
func (m *RepositoryMutation) SetWatchers(i int64) {
	m.watchers = &i
	m.addwatchers = nil
}

// Watchers returns the value of the "watchers" field in the mutation.
func (m *RepositoryMutation) Watchers() (r int64, exists bool) {
	v := m.watchers
	if v == nil {
		return
	}
	return *v, true
}

// OldWatchers returns the old "watchers" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldWatchers(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWatchers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWatchers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatchers: %w", err)
	}
	return oldValue.Watchers, nil
}

// AddWatchers adds i to the "watchers" field.
func (m *RepositoryMutation) AddWatchers(i int64) {
	if m.addwatchers != nil {
		*m.addwatchers += i
	} else {
		m.addwatchers = &i
	}
}

// AddedWatchers returns the value that was added to the "watchers" field in this mutation.
func (m *RepositoryMutation) AddedWatchers() (r int64, exists bool) {
	v := m.addwatchers
	if v == nil {
		return
	}
	return *v, true
}

// ResetWatchers resets all changes to the "watchers" field.
func (m *RepositoryMutation) ResetWatchers() {
	m.watchers = nil
	m.addwatchers = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *RepositoryMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *RepositoryMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *RepositoryMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *RepositoryMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *RepositoryMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *RepositoryMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddIssueIDs adds the "issues" edge to the Issue entity by ids.
func (m *RepositoryMutation) AddIssueIDs(ids ...int64) {
	if m.issues == nil {
		m.issues = make(map[int64]struct{})
	}
	for i := range ids {
		m.issues[ids[i]] = struct{}{}
	}
}

// ClearIssues clears the "issues" edge to the Issue entity.
func (m *RepositoryMutation) ClearIssues() {
	m.clearedissues = true
}

// IssuesCleared reports if the "issues" edge to the Issue entity was cleared.
func (m *RepositoryMutation) IssuesCleared() bool {
	return m.clearedissues
}

// RemoveIssueIDs removes the "issues" edge to the Issue entity by IDs.
func (m *RepositoryMutation) RemoveIssueIDs(ids ...int64) {
	if m.removedissues == nil {
		m.removedissues = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.issues, ids[i])
		m.removedissues[ids[i]] = struct{}{}
	}
}

// RemovedIssues returns the removed IDs of the "issues" edge to the Issue entity.
func (m *RepositoryMutation) RemovedIssuesIDs() (ids []int64) {
	for id := range m.removedissues {
		ids = append(ids, id)
	}
	return
}

// IssuesIDs returns the "issues" edge IDs in the mutation.
func (m *RepositoryMutation) IssuesIDs() (ids []int64) {
	for id := range m.issues {
		ids = append(ids, id)
	}
	return
}

// ResetIssues resets all changes to the "issues" edge.
func (m *RepositoryMutation) ResetIssues() {
	m.issues = nil
	m.clearedissues = false
	m.removedissues = nil
}

// Where appends a list predicates to the RepositoryMutation builder.
func (m *RepositoryMutation) Where(ps ...predicate.Repository) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RepositoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RepositoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Repository, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RepositoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 76)
	if m.node_id != nil {
		fields = append(fields, repository.FieldNodeID)
	}
	if m.name != nil {
		fields = append(fields, repository.FieldName)
	}
	if m.full_name != nil {
		fields = append(fields, repository.FieldFullName)
	}
	if m.private != nil {
		fields = append(fields, repository.FieldPrivate)
	}
	if m.html_url != nil {
		fields = append(fields, repository.FieldHTMLURL)
	}
	if m.description != nil {
		fields = append(fields, repository.FieldDescription)
	}
	if m.fork != nil {
		fields = append(fields, repository.FieldFork)
	}
	if m.url != nil {
		fields = append(fields, repository.FieldURL)
	}
	if m.archive_url != nil {
		fields = append(fields, repository.FieldArchiveURL)
	}
	if m.assignees_url != nil {
		fields = append(fields, repository.FieldAssigneesURL)
	}
	if m.blobs_url != nil {
		fields = append(fields, repository.FieldBlobsURL)
	}
	if m.branches_url != nil {
		fields = append(fields, repository.FieldBranchesURL)
	}
	if m.collaborators_url != nil {
		fields = append(fields, repository.FieldCollaboratorsURL)
	}
	if m.comments_url != nil {
		fields = append(fields, repository.FieldCommentsURL)
	}
	if m.commits_url != nil {
		fields = append(fields, repository.FieldCommitsURL)
	}
	if m.compare_url != nil {
		fields = append(fields, repository.FieldCompareURL)
	}
	if m.contents_url != nil {
		fields = append(fields, repository.FieldContentsURL)
	}
	if m.contributors_url != nil {
		fields = append(fields, repository.FieldContributorsURL)
	}
	if m.deployments_url != nil {
		fields = append(fields, repository.FieldDeploymentsURL)
	}
	if m.downloads_url != nil {
		fields = append(fields, repository.FieldDownloadsURL)
	}
	if m.events_url != nil {
		fields = append(fields, repository.FieldEventsURL)
	}
	if m.forks_url != nil {
		fields = append(fields, repository.FieldForksURL)
	}
	if m.git_commits_url != nil {
		fields = append(fields, repository.FieldGitCommitsURL)
	}
	if m.git_refs_url != nil {
		fields = append(fields, repository.FieldGitRefsURL)
	}
	if m.git_tags_url != nil {
		fields = append(fields, repository.FieldGitTagsURL)
	}
	if m.git_url != nil {
		fields = append(fields, repository.FieldGitURL)
	}
	if m.issue_comment_url != nil {
		fields = append(fields, repository.FieldIssueCommentURL)
	}
	if m.issue_events_url != nil {
		fields = append(fields, repository.FieldIssueEventsURL)
	}
	if m.issues_url != nil {
		fields = append(fields, repository.FieldIssuesURL)
	}
	if m.keys_url != nil {
		fields = append(fields, repository.FieldKeysURL)
	}
	if m.labels_url != nil {
		fields = append(fields, repository.FieldLabelsURL)
	}
	if m.languages_url != nil {
		fields = append(fields, repository.FieldLanguagesURL)
	}
	if m.merges_url != nil {
		fields = append(fields, repository.FieldMergesURL)
	}
	if m.milestones_url != nil {
		fields = append(fields, repository.FieldMilestonesURL)
	}
	if m.notifications_url != nil {
		fields = append(fields, repository.FieldNotificationsURL)
	}
	if m.pulls_url != nil {
		fields = append(fields, repository.FieldPullsURL)
	}
	if m.releases_url != nil {
		fields = append(fields, repository.FieldReleasesURL)
	}
	if m.ssh_url != nil {
		fields = append(fields, repository.FieldSSHURL)
	}
	if m.stargazers_url != nil {
		fields = append(fields, repository.FieldStargazersURL)
	}
	if m.statuses_url != nil {
		fields = append(fields, repository.FieldStatusesURL)
	}
	if m.subscribers_url != nil {
		fields = append(fields, repository.FieldSubscribersURL)
	}
	if m.subscription_url != nil {
		fields = append(fields, repository.FieldSubscriptionURL)
	}
	if m.tags_url != nil {
		fields = append(fields, repository.FieldTagsURL)
	}
	if m.teams_url != nil {
		fields = append(fields, repository.FieldTeamsURL)
	}
	if m.trees_url != nil {
		fields = append(fields, repository.FieldTreesURL)
	}
	if m.clone_url != nil {
		fields = append(fields, repository.FieldCloneURL)
	}
	if m.mirror_url != nil {
		fields = append(fields, repository.FieldMirrorURL)
	}
	if m.hooks_url != nil {
		fields = append(fields, repository.FieldHooksURL)
	}
	if m.svn_url != nil {
		fields = append(fields, repository.FieldSvnURL)
	}
	if m.homepage != nil {
		fields = append(fields, repository.FieldHomepage)
	}
	if m.language != nil {
		fields = append(fields, repository.FieldLanguage)
	}
	if m.forks_count != nil {
		fields = append(fields, repository.FieldForksCount)
	}
	if m.stargazers_count != nil {
		fields = append(fields, repository.FieldStargazersCount)
	}
	if m.watchers_count != nil {
		fields = append(fields, repository.FieldWatchersCount)
	}
	if m.size != nil {
		fields = append(fields, repository.FieldSize)
	}
	if m.default_branch != nil {
		fields = append(fields, repository.FieldDefaultBranch)
	}
	if m.open_issues_count != nil {
		fields = append(fields, repository.FieldOpenIssuesCount)
	}
	if m.is_template != nil {
		fields = append(fields, repository.FieldIsTemplate)
	}
	if m.topics != nil {
		fields = append(fields, repository.FieldTopics)
	}
	if m.has_issues_enabled != nil {
		fields = append(fields, repository.FieldHasIssuesEnabled)
	}
	if m.has_projects != nil {
		fields = append(fields, repository.FieldHasProjects)
	}
	if m.has_wiki != nil {
		fields = append(fields, repository.FieldHasWiki)
	}
	if m.has_pages != nil {
		fields = append(fields, repository.FieldHasPages)
	}
	if m.has_downloads != nil {
		fields = append(fields, repository.FieldHasDownloads)
	}
	if m.has_discussions != nil {
		fields = append(fields, repository.FieldHasDiscussions)
	}
	if m.archived != nil {
		fields = append(fields, repository.FieldArchived)
	}
	if m.disabled != nil {
		fields = append(fields, repository.FieldDisabled)
	}
	if m.visibility != nil {
		fields = append(fields, repository.FieldVisibility)
	}
	if m.pushed_at != nil {
		fields = append(fields, repository.FieldPushedAt)
	}
	if m.created_at != nil {
		fields = append(fields, repository.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, repository.FieldUpdatedAt)
	}
	if m.subscribers_count != nil {
		fields = append(fields, repository.FieldSubscribersCount)
	}
	if m.network_count != nil {
		fields = append(fields, repository.FieldNetworkCount)
	}
	if m.forks != nil {
		fields = append(fields, repository.FieldForks)
	}
	if m.open_issues != nil {
		fields = append(fields, repository.FieldOpenIssues)
	}
	if m.watchers != nil {
		fields = append(fields, repository.FieldWatchers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldNodeID:
		return m.NodeID()
	case repository.FieldName:
		return m.Name()
	case repository.FieldFullName:
		return m.FullName()
	case repository.FieldPrivate:
		return m.Private()
	case repository.FieldHTMLURL:
		return m.HTMLURL()
	case repository.FieldDescription:
		return m.Description()
	case repository.FieldFork:
		return m.Fork()
	case repository.FieldURL:
		return m.URL()
	case repository.FieldArchiveURL:
		return m.ArchiveURL()
	case repository.FieldAssigneesURL:
		return m.AssigneesURL()
	case repository.FieldBlobsURL:
		return m.BlobsURL()
	case repository.FieldBranchesURL:
		return m.BranchesURL()
	case repository.FieldCollaboratorsURL:
		return m.CollaboratorsURL()
	case repository.FieldCommentsURL:
		return m.CommentsURL()
	case repository.FieldCommitsURL:
		return m.CommitsURL()
	case repository.FieldCompareURL:
		return m.CompareURL()
	case repository.FieldContentsURL:
		return m.ContentsURL()
	case repository.FieldContributorsURL:
		return m.ContributorsURL()
	case repository.FieldDeploymentsURL:
		return m.DeploymentsURL()
	case repository.FieldDownloadsURL:
		return m.DownloadsURL()
	case repository.FieldEventsURL:
		return m.EventsURL()
	case repository.FieldForksURL:
		return m.ForksURL()
	case repository.FieldGitCommitsURL:
		return m.GitCommitsURL()
	case repository.FieldGitRefsURL:
		return m.GitRefsURL()
	case repository.FieldGitTagsURL:
		return m.GitTagsURL()
	case repository.FieldGitURL:
		return m.GitURL()
	case repository.FieldIssueCommentURL:
		return m.IssueCommentURL()
	case repository.FieldIssueEventsURL:
		return m.IssueEventsURL()
	case repository.FieldIssuesURL:
		return m.IssuesURL()
	case repository.FieldKeysURL:
		return m.KeysURL()
	case repository.FieldLabelsURL:
		return m.LabelsURL()
	case repository.FieldLanguagesURL:
		return m.LanguagesURL()
	case repository.FieldMergesURL:
		return m.MergesURL()
	case repository.FieldMilestonesURL:
		return m.MilestonesURL()
	case repository.FieldNotificationsURL:
		return m.NotificationsURL()
	case repository.FieldPullsURL:
		return m.PullsURL()
	case repository.FieldReleasesURL:
		return m.ReleasesURL()
	case repository.FieldSSHURL:
		return m.SSHURL()
	case repository.FieldStargazersURL:
		return m.StargazersURL()
	case repository.FieldStatusesURL:
		return m.StatusesURL()
	case repository.FieldSubscribersURL:
		return m.SubscribersURL()
	case repository.FieldSubscriptionURL:
		return m.SubscriptionURL()
	case repository.FieldTagsURL:
		return m.TagsURL()
	case repository.FieldTeamsURL:
		return m.TeamsURL()
	case repository.FieldTreesURL:
		return m.TreesURL()
	case repository.FieldCloneURL:
		return m.CloneURL()
	case repository.FieldMirrorURL:
		return m.MirrorURL()
	case repository.FieldHooksURL:
		return m.HooksURL()
	case repository.FieldSvnURL:
		return m.SvnURL()
	case repository.FieldHomepage:
		return m.Homepage()
	case repository.FieldLanguage:
		return m.Language()
	case repository.FieldForksCount:
		return m.ForksCount()
	case repository.FieldStargazersCount:
		return m.StargazersCount()
	case repository.FieldWatchersCount:
		return m.WatchersCount()
	case repository.FieldSize:
		return m.Size()
	case repository.FieldDefaultBranch:
		return m.DefaultBranch()
	case repository.FieldOpenIssuesCount:
		return m.OpenIssuesCount()
	case repository.FieldIsTemplate:
		return m.IsTemplate()
	case repository.FieldTopics:
		return m.Topics()
	case repository.FieldHasIssuesEnabled:
		return m.HasIssuesEnabled()
	case repository.FieldHasProjects:
		return m.HasProjects()
	case repository.FieldHasWiki:
		return m.HasWiki()
	case repository.FieldHasPages:
		return m.HasPages()
	case repository.FieldHasDownloads:
		return m.HasDownloads()
	case repository.FieldHasDiscussions:
		return m.HasDiscussions()
	case repository.FieldArchived:
		return m.Archived()
	case repository.FieldDisabled:
		return m.Disabled()
	case repository.FieldVisibility:
		return m.Visibility()
	case repository.FieldPushedAt:
		return m.PushedAt()
	case repository.FieldCreatedAt:
		return m.CreatedAt()
	case repository.FieldUpdatedAt:
		return m.UpdatedAt()
	case repository.FieldSubscribersCount:
		return m.SubscribersCount()
	case repository.FieldNetworkCount:
		return m.NetworkCount()
	case repository.FieldForks:
		return m.Forks()
	case repository.FieldOpenIssues:
		return m.OpenIssues()
	case repository.FieldWatchers:
		return m.Watchers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldNodeID:
		return m.OldNodeID(ctx)
	case repository.FieldName:
		return m.OldName(ctx)
	case repository.FieldFullName:
		return m.OldFullName(ctx)
	case repository.FieldPrivate:
		return m.OldPrivate(ctx)
	case repository.FieldHTMLURL:
		return m.OldHTMLURL(ctx)
	case repository.FieldDescription:
		return m.OldDescription(ctx)
	case repository.FieldFork:
		return m.OldFork(ctx)
	case repository.FieldURL:
		return m.OldURL(ctx)
	case repository.FieldArchiveURL:
		return m.OldArchiveURL(ctx)
	case repository.FieldAssigneesURL:
		return m.OldAssigneesURL(ctx)
	case repository.FieldBlobsURL:
		return m.OldBlobsURL(ctx)
	case repository.FieldBranchesURL:
		return m.OldBranchesURL(ctx)
	case repository.FieldCollaboratorsURL:
		return m.OldCollaboratorsURL(ctx)
	case repository.FieldCommentsURL:
		return m.OldCommentsURL(ctx)
	case repository.FieldCommitsURL:
		return m.OldCommitsURL(ctx)
	case repository.FieldCompareURL:
		return m.OldCompareURL(ctx)
	case repository.FieldContentsURL:
		return m.OldContentsURL(ctx)
	case repository.FieldContributorsURL:
		return m.OldContributorsURL(ctx)
	case repository.FieldDeploymentsURL:
		return m.OldDeploymentsURL(ctx)
	case repository.FieldDownloadsURL:
		return m.OldDownloadsURL(ctx)
	case repository.FieldEventsURL:
		return m.OldEventsURL(ctx)
	case repository.FieldForksURL:
		return m.OldForksURL(ctx)
	case repository.FieldGitCommitsURL:
		return m.OldGitCommitsURL(ctx)
	case repository.FieldGitRefsURL:
		return m.OldGitRefsURL(ctx)
	case repository.FieldGitTagsURL:
		return m.OldGitTagsURL(ctx)
	case repository.FieldGitURL:
		return m.OldGitURL(ctx)
	case repository.FieldIssueCommentURL:
		return m.OldIssueCommentURL(ctx)
	case repository.FieldIssueEventsURL:
		return m.OldIssueEventsURL(ctx)
	case repository.FieldIssuesURL:
		return m.OldIssuesURL(ctx)
	case repository.FieldKeysURL:
		return m.OldKeysURL(ctx)
	case repository.FieldLabelsURL:
		return m.OldLabelsURL(ctx)
	case repository.FieldLanguagesURL:
		return m.OldLanguagesURL(ctx)
	case repository.FieldMergesURL:
		return m.OldMergesURL(ctx)
	case repository.FieldMilestonesURL:
		return m.OldMilestonesURL(ctx)
	case repository.FieldNotificationsURL:
		return m.OldNotificationsURL(ctx)
	case repository.FieldPullsURL:
		return m.OldPullsURL(ctx)
	case repository.FieldReleasesURL:
		return m.OldReleasesURL(ctx)
	case repository.FieldSSHURL:
		return m.OldSSHURL(ctx)
	case repository.FieldStargazersURL:
		return m.OldStargazersURL(ctx)
	case repository.FieldStatusesURL:
		return m.OldStatusesURL(ctx)
	case repository.FieldSubscribersURL:
		return m.OldSubscribersURL(ctx)
	case repository.FieldSubscriptionURL:
		return m.OldSubscriptionURL(ctx)
	case repository.FieldTagsURL:
		return m.OldTagsURL(ctx)
	case repository.FieldTeamsURL:
		return m.OldTeamsURL(ctx)
	case repository.FieldTreesURL:
		return m.OldTreesURL(ctx)
	case repository.FieldCloneURL:
		return m.OldCloneURL(ctx)
	case repository.FieldMirrorURL:
		return m.OldMirrorURL(ctx)
	case repository.FieldHooksURL:
		return m.OldHooksURL(ctx)
	case repository.FieldSvnURL:
		return m.OldSvnURL(ctx)
	case repository.FieldHomepage:
		return m.OldHomepage(ctx)
	case repository.FieldLanguage:
		return m.OldLanguage(ctx)
	case repository.FieldForksCount:
		return m.OldForksCount(ctx)
	case repository.FieldStargazersCount:
		return m.OldStargazersCount(ctx)
	case repository.FieldWatchersCount:
		return m.OldWatchersCount(ctx)
	case repository.FieldSize:
		return m.OldSize(ctx)
	case repository.FieldDefaultBranch:
		return m.OldDefaultBranch(ctx)
	case repository.FieldOpenIssuesCount:
		return m.OldOpenIssuesCount(ctx)
	case repository.FieldIsTemplate:
		return m.OldIsTemplate(ctx)
	case repository.FieldTopics:
		return m.OldTopics(ctx)
	case repository.FieldHasIssuesEnabled:
		return m.OldHasIssuesEnabled(ctx)
	case repository.FieldHasProjects:
		return m.OldHasProjects(ctx)
	case repository.FieldHasWiki:
		return m.OldHasWiki(ctx)
	case repository.FieldHasPages:
		return m.OldHasPages(ctx)
	case repository.FieldHasDownloads:
		return m.OldHasDownloads(ctx)
	case repository.FieldHasDiscussions:
		return m.OldHasDiscussions(ctx)
	case repository.FieldArchived:
		return m.OldArchived(ctx)
	case repository.FieldDisabled:
		return m.OldDisabled(ctx)
	case repository.FieldVisibility:
		return m.OldVisibility(ctx)
	case repository.FieldPushedAt:
		return m.OldPushedAt(ctx)
	case repository.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case repository.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case repository.FieldSubscribersCount:
		return m.OldSubscribersCount(ctx)
	case repository.FieldNetworkCount:
		return m.OldNetworkCount(ctx)
	case repository.FieldForks:
		return m.OldForks(ctx)
	case repository.FieldOpenIssues:
		return m.OldOpenIssues(ctx)
	case repository.FieldWatchers:
		return m.OldWatchers(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case repository.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case repository.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case repository.FieldPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivate(v)
		return nil
	case repository.FieldHTMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLURL(v)
		return nil
	case repository.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case repository.FieldFork:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFork(v)
		return nil
	case repository.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case repository.FieldArchiveURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchiveURL(v)
		return nil
	case repository.FieldAssigneesURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneesURL(v)
		return nil
	case repository.FieldBlobsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlobsURL(v)
		return nil
	case repository.FieldBranchesURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchesURL(v)
		return nil
	case repository.FieldCollaboratorsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollaboratorsURL(v)
		return nil
	case repository.FieldCommentsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentsURL(v)
		return nil
	case repository.FieldCommitsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitsURL(v)
		return nil
	case repository.FieldCompareURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompareURL(v)
		return nil
	case repository.FieldContentsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentsURL(v)
		return nil
	case repository.FieldContributorsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContributorsURL(v)
		return nil
	case repository.FieldDeploymentsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentsURL(v)
		return nil
	case repository.FieldDownloadsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadsURL(v)
		return nil
	case repository.FieldEventsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventsURL(v)
		return nil
	case repository.FieldForksURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForksURL(v)
		return nil
	case repository.FieldGitCommitsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitsURL(v)
		return nil
	case repository.FieldGitRefsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitRefsURL(v)
		return nil
	case repository.FieldGitTagsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitTagsURL(v)
		return nil
	case repository.FieldGitURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitURL(v)
		return nil
	case repository.FieldIssueCommentURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueCommentURL(v)
		return nil
	case repository.FieldIssueEventsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssueEventsURL(v)
		return nil
	case repository.FieldIssuesURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuesURL(v)
		return nil
	case repository.FieldKeysURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeysURL(v)
		return nil
	case repository.FieldLabelsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelsURL(v)
		return nil
	case repository.FieldLanguagesURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguagesURL(v)
		return nil
	case repository.FieldMergesURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMergesURL(v)
		return nil
	case repository.FieldMilestonesURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMilestonesURL(v)
		return nil
	case repository.FieldNotificationsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationsURL(v)
		return nil
	case repository.FieldPullsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullsURL(v)
		return nil
	case repository.FieldReleasesURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasesURL(v)
		return nil
	case repository.FieldSSHURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSHURL(v)
		return nil
	case repository.FieldStargazersURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStargazersURL(v)
		return nil
	case repository.FieldStatusesURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusesURL(v)
		return nil
	case repository.FieldSubscribersURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribersURL(v)
		return nil
	case repository.FieldSubscriptionURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionURL(v)
		return nil
	case repository.FieldTagsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagsURL(v)
		return nil
	case repository.FieldTeamsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamsURL(v)
		return nil
	case repository.FieldTreesURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreesURL(v)
		return nil
	case repository.FieldCloneURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloneURL(v)
		return nil
	case repository.FieldMirrorURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMirrorURL(v)
		return nil
	case repository.FieldHooksURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHooksURL(v)
		return nil
	case repository.FieldSvnURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSvnURL(v)
		return nil
	case repository.FieldHomepage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomepage(v)
		return nil
	case repository.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case repository.FieldForksCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForksCount(v)
		return nil
	case repository.FieldStargazersCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStargazersCount(v)
		return nil
	case repository.FieldWatchersCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatchersCount(v)
		return nil
	case repository.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case repository.FieldDefaultBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultBranch(v)
		return nil
	case repository.FieldOpenIssuesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenIssuesCount(v)
		return nil
	case repository.FieldIsTemplate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTemplate(v)
		return nil
	case repository.FieldTopics:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopics(v)
		return nil
	case repository.FieldHasIssuesEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasIssuesEnabled(v)
		return nil
	case repository.FieldHasProjects:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasProjects(v)
		return nil
	case repository.FieldHasWiki:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasWiki(v)
		return nil
	case repository.FieldHasPages:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPages(v)
		return nil
	case repository.FieldHasDownloads:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasDownloads(v)
		return nil
	case repository.FieldHasDiscussions:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasDiscussions(v)
		return nil
	case repository.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	case repository.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case repository.FieldVisibility:
		v, ok := value.(repository.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case repository.FieldPushedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushedAt(v)
		return nil
	case repository.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case repository.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case repository.FieldSubscribersCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribersCount(v)
		return nil
	case repository.FieldNetworkCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkCount(v)
		return nil
	case repository.FieldForks:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForks(v)
		return nil
	case repository.FieldOpenIssues:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenIssues(v)
		return nil
	case repository.FieldWatchers:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatchers(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	var fields []string
	if m.addforks_count != nil {
		fields = append(fields, repository.FieldForksCount)
	}
	if m.addstargazers_count != nil {
		fields = append(fields, repository.FieldStargazersCount)
	}
	if m.addwatchers_count != nil {
		fields = append(fields, repository.FieldWatchersCount)
	}
	if m.addsize != nil {
		fields = append(fields, repository.FieldSize)
	}
	if m.addopen_issues_count != nil {
		fields = append(fields, repository.FieldOpenIssuesCount)
	}
	if m.addsubscribers_count != nil {
		fields = append(fields, repository.FieldSubscribersCount)
	}
	if m.addnetwork_count != nil {
		fields = append(fields, repository.FieldNetworkCount)
	}
	if m.addforks != nil {
		fields = append(fields, repository.FieldForks)
	}
	if m.addopen_issues != nil {
		fields = append(fields, repository.FieldOpenIssues)
	}
	if m.addwatchers != nil {
		fields = append(fields, repository.FieldWatchers)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldForksCount:
		return m.AddedForksCount()
	case repository.FieldStargazersCount:
		return m.AddedStargazersCount()
	case repository.FieldWatchersCount:
		return m.AddedWatchersCount()
	case repository.FieldSize:
		return m.AddedSize()
	case repository.FieldOpenIssuesCount:
		return m.AddedOpenIssuesCount()
	case repository.FieldSubscribersCount:
		return m.AddedSubscribersCount()
	case repository.FieldNetworkCount:
		return m.AddedNetworkCount()
	case repository.FieldForks:
		return m.AddedForks()
	case repository.FieldOpenIssues:
		return m.AddedOpenIssues()
	case repository.FieldWatchers:
		return m.AddedWatchers()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repository.FieldForksCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddForksCount(v)
		return nil
	case repository.FieldStargazersCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStargazersCount(v)
		return nil
	case repository.FieldWatchersCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWatchersCount(v)
		return nil
	case repository.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case repository.FieldOpenIssuesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpenIssuesCount(v)
		return nil
	case repository.FieldSubscribersCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubscribersCount(v)
		return nil
	case repository.FieldNetworkCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetworkCount(v)
		return nil
	case repository.FieldForks:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddForks(v)
		return nil
	case repository.FieldOpenIssues:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpenIssues(v)
		return nil
	case repository.FieldWatchers:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWatchers(v)
		return nil
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(repository.FieldDescription) {
		fields = append(fields, repository.FieldDescription)
	}
	if m.FieldCleared(repository.FieldMirrorURL) {
		fields = append(fields, repository.FieldMirrorURL)
	}
	if m.FieldCleared(repository.FieldHomepage) {
		fields = append(fields, repository.FieldHomepage)
	}
	if m.FieldCleared(repository.FieldLanguage) {
		fields = append(fields, repository.FieldLanguage)
	}
	if m.FieldCleared(repository.FieldVisibility) {
		fields = append(fields, repository.FieldVisibility)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	switch name {
	case repository.FieldDescription:
		m.ClearDescription()
		return nil
	case repository.FieldMirrorURL:
		m.ClearMirrorURL()
		return nil
	case repository.FieldHomepage:
		m.ClearHomepage()
		return nil
	case repository.FieldLanguage:
		m.ClearLanguage()
		return nil
	case repository.FieldVisibility:
		m.ClearVisibility()
		return nil
	}
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldNodeID:
		m.ResetNodeID()
		return nil
	case repository.FieldName:
		m.ResetName()
		return nil
	case repository.FieldFullName:
		m.ResetFullName()
		return nil
	case repository.FieldPrivate:
		m.ResetPrivate()
		return nil
	case repository.FieldHTMLURL:
		m.ResetHTMLURL()
		return nil
	case repository.FieldDescription:
		m.ResetDescription()
		return nil
	case repository.FieldFork:
		m.ResetFork()
		return nil
	case repository.FieldURL:
		m.ResetURL()
		return nil
	case repository.FieldArchiveURL:
		m.ResetArchiveURL()
		return nil
	case repository.FieldAssigneesURL:
		m.ResetAssigneesURL()
		return nil
	case repository.FieldBlobsURL:
		m.ResetBlobsURL()
		return nil
	case repository.FieldBranchesURL:
		m.ResetBranchesURL()
		return nil
	case repository.FieldCollaboratorsURL:
		m.ResetCollaboratorsURL()
		return nil
	case repository.FieldCommentsURL:
		m.ResetCommentsURL()
		return nil
	case repository.FieldCommitsURL:
		m.ResetCommitsURL()
		return nil
	case repository.FieldCompareURL:
		m.ResetCompareURL()
		return nil
	case repository.FieldContentsURL:
		m.ResetContentsURL()
		return nil
	case repository.FieldContributorsURL:
		m.ResetContributorsURL()
		return nil
	case repository.FieldDeploymentsURL:
		m.ResetDeploymentsURL()
		return nil
	case repository.FieldDownloadsURL:
		m.ResetDownloadsURL()
		return nil
	case repository.FieldEventsURL:
		m.ResetEventsURL()
		return nil
	case repository.FieldForksURL:
		m.ResetForksURL()
		return nil
	case repository.FieldGitCommitsURL:
		m.ResetGitCommitsURL()
		return nil
	case repository.FieldGitRefsURL:
		m.ResetGitRefsURL()
		return nil
	case repository.FieldGitTagsURL:
		m.ResetGitTagsURL()
		return nil
	case repository.FieldGitURL:
		m.ResetGitURL()
		return nil
	case repository.FieldIssueCommentURL:
		m.ResetIssueCommentURL()
		return nil
	case repository.FieldIssueEventsURL:
		m.ResetIssueEventsURL()
		return nil
	case repository.FieldIssuesURL:
		m.ResetIssuesURL()
		return nil
	case repository.FieldKeysURL:
		m.ResetKeysURL()
		return nil
	case repository.FieldLabelsURL:
		m.ResetLabelsURL()
		return nil
	case repository.FieldLanguagesURL:
		m.ResetLanguagesURL()
		return nil
	case repository.FieldMergesURL:
		m.ResetMergesURL()
		return nil
	case repository.FieldMilestonesURL:
		m.ResetMilestonesURL()
		return nil
	case repository.FieldNotificationsURL:
		m.ResetNotificationsURL()
		return nil
	case repository.FieldPullsURL:
		m.ResetPullsURL()
		return nil
	case repository.FieldReleasesURL:
		m.ResetReleasesURL()
		return nil
	case repository.FieldSSHURL:
		m.ResetSSHURL()
		return nil
	case repository.FieldStargazersURL:
		m.ResetStargazersURL()
		return nil
	case repository.FieldStatusesURL:
		m.ResetStatusesURL()
		return nil
	case repository.FieldSubscribersURL:
		m.ResetSubscribersURL()
		return nil
	case repository.FieldSubscriptionURL:
		m.ResetSubscriptionURL()
		return nil
	case repository.FieldTagsURL:
		m.ResetTagsURL()
		return nil
	case repository.FieldTeamsURL:
		m.ResetTeamsURL()
		return nil
	case repository.FieldTreesURL:
		m.ResetTreesURL()
		return nil
	case repository.FieldCloneURL:
		m.ResetCloneURL()
		return nil
	case repository.FieldMirrorURL:
		m.ResetMirrorURL()
		return nil
	case repository.FieldHooksURL:
		m.ResetHooksURL()
		return nil
	case repository.FieldSvnURL:
		m.ResetSvnURL()
		return nil
	case repository.FieldHomepage:
		m.ResetHomepage()
		return nil
	case repository.FieldLanguage:
		m.ResetLanguage()
		return nil
	case repository.FieldForksCount:
		m.ResetForksCount()
		return nil
	case repository.FieldStargazersCount:
		m.ResetStargazersCount()
		return nil
	case repository.FieldWatchersCount:
		m.ResetWatchersCount()
		return nil
	case repository.FieldSize:
		m.ResetSize()
		return nil
	case repository.FieldDefaultBranch:
		m.ResetDefaultBranch()
		return nil
	case repository.FieldOpenIssuesCount:
		m.ResetOpenIssuesCount()
		return nil
	case repository.FieldIsTemplate:
		m.ResetIsTemplate()
		return nil
	case repository.FieldTopics:
		m.ResetTopics()
		return nil
	case repository.FieldHasIssuesEnabled:
		m.ResetHasIssuesEnabled()
		return nil
	case repository.FieldHasProjects:
		m.ResetHasProjects()
		return nil
	case repository.FieldHasWiki:
		m.ResetHasWiki()
		return nil
	case repository.FieldHasPages:
		m.ResetHasPages()
		return nil
	case repository.FieldHasDownloads:
		m.ResetHasDownloads()
		return nil
	case repository.FieldHasDiscussions:
		m.ResetHasDiscussions()
		return nil
	case repository.FieldArchived:
		m.ResetArchived()
		return nil
	case repository.FieldDisabled:
		m.ResetDisabled()
		return nil
	case repository.FieldVisibility:
		m.ResetVisibility()
		return nil
	case repository.FieldPushedAt:
		m.ResetPushedAt()
		return nil
	case repository.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case repository.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case repository.FieldSubscribersCount:
		m.ResetSubscribersCount()
		return nil
	case repository.FieldNetworkCount:
		m.ResetNetworkCount()
		return nil
	case repository.FieldForks:
		m.ResetForks()
		return nil
	case repository.FieldOpenIssues:
		m.ResetOpenIssues()
		return nil
	case repository.FieldWatchers:
		m.ResetWatchers()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, repository.EdgeOwner)
	}
	if m.issues != nil {
		edges = append(edges, repository.EdgeIssues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case repository.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.issues))
		for id := range m.issues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedissues != nil {
		edges = append(edges, repository.EdgeIssues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.removedissues))
		for id := range m.removedissues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, repository.EdgeOwner)
	}
	if m.clearedissues {
		edges = append(edges, repository.EdgeIssues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgeOwner:
		return m.clearedowner
	case repository.EdgeIssues:
		return m.clearedissues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	case repository.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgeOwner:
		m.ResetOwner()
		return nil
	case repository.EdgeIssues:
		m.ResetIssues()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	login                   *string
	node_id                 *string
	avatar_url              *string
	gravatar_id             *string
	url                     *string
	html_url                *string
	followers_url           *string
	following_url           *string
	gists_url               *string
	starred_url             *string
	subscriptions_url       *string
	organizations_url       *string
	repos_url               *string
	events_url              *string
	received_events_url     *string
	_type                   *string
	site_admin              *bool
	name                    *string
	company                 *string
	blog                    *string
	location                *string
	email                   *string
	hireable                *bool
	bio                     *string
	public_repos            *int64
	addpublic_repos         *int64
	public_gists            *int64
	addpublic_gists         *int64
	followers               *int64
	addfollowers            *int64
	following               *int64
	addfollowing            *int64
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	repositories            map[int64]struct{}
	removedrepositories     map[int64]struct{}
	clearedrepositories     bool
	issues_created          map[int64]struct{}
	removedissues_created   map[int64]struct{}
	clearedissues_created   bool
	comments_created        map[int64]struct{}
	removedcomments_created map[int64]struct{}
	clearedcomments_created bool
	issues_assigned         map[int64]struct{}
	removedissues_assigned  map[int64]struct{}
	clearedissues_assigned  bool
	issues_closed           map[int64]struct{}
	removedissues_closed    map[int64]struct{}
	clearedissues_closed    bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLogin sets the "login" field.
func (m *UserMutation) SetLogin(s string) {
	m.login = &s
}

// Login returns the value of the "login" field in the mutation.
func (m *UserMutation) Login() (r string, exists bool) {
	v := m.login
	if v == nil {
		return
	}
	return *v, true
}

// OldLogin returns the old "login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogin: %w", err)
	}
	return oldValue.Login, nil
}

// ResetLogin resets all changes to the "login" field.
func (m *UserMutation) ResetLogin() {
	m.login = nil
}

// SetNodeID sets the "node_id" field.
func (m *UserMutation) SetNodeID(s string) {
	m.node_id = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *UserMutation) NodeID() (r string, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *UserMutation) ResetNodeID() {
	m.node_id = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetGravatarID sets the "gravatar_id" field.
func (m *UserMutation) SetGravatarID(s string) {
	m.gravatar_id = &s
}

// GravatarID returns the value of the "gravatar_id" field in the mutation.
func (m *UserMutation) GravatarID() (r string, exists bool) {
	v := m.gravatar_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGravatarID returns the old "gravatar_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGravatarID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGravatarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGravatarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGravatarID: %w", err)
	}
	return oldValue.GravatarID, nil
}

// ClearGravatarID clears the value of the "gravatar_id" field.
func (m *UserMutation) ClearGravatarID() {
	m.gravatar_id = nil
	m.clearedFields[user.FieldGravatarID] = struct{}{}
}

// GravatarIDCleared returns if the "gravatar_id" field was cleared in this mutation.
func (m *UserMutation) GravatarIDCleared() bool {
	_, ok := m.clearedFields[user.FieldGravatarID]
	return ok
}

// ResetGravatarID resets all changes to the "gravatar_id" field.
func (m *UserMutation) ResetGravatarID() {
	m.gravatar_id = nil
	delete(m.clearedFields, user.FieldGravatarID)
}

// SetURL sets the "url" field.
func (m *UserMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *UserMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *UserMutation) ResetURL() {
	m.url = nil
}

// SetHTMLURL sets the "html_url" field.
func (m *UserMutation) SetHTMLURL(s string) {
	m.html_url = &s
}

// HTMLURL returns the value of the "html_url" field in the mutation.
func (m *UserMutation) HTMLURL() (r string, exists bool) {
	v := m.html_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLURL returns the old "html_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHTMLURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLURL: %w", err)
	}
	return oldValue.HTMLURL, nil
}

// ResetHTMLURL resets all changes to the "html_url" field.
func (m *UserMutation) ResetHTMLURL() {
	m.html_url = nil
}

// SetFollowersURL sets the "followers_url" field.
func (m *UserMutation) SetFollowersURL(s string) {
	m.followers_url = &s
}

// FollowersURL returns the value of the "followers_url" field in the mutation.
func (m *UserMutation) FollowersURL() (r string, exists bool) {
	v := m.followers_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowersURL returns the old "followers_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFollowersURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowersURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowersURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowersURL: %w", err)
	}
	return oldValue.FollowersURL, nil
}

// ResetFollowersURL resets all changes to the "followers_url" field.
func (m *UserMutation) ResetFollowersURL() {
	m.followers_url = nil
}

// SetFollowingURL sets the "following_url" field.
func (m *UserMutation) SetFollowingURL(s string) {
	m.following_url = &s
}

// FollowingURL returns the value of the "following_url" field in the mutation.
func (m *UserMutation) FollowingURL() (r string, exists bool) {
	v := m.following_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingURL returns the old "following_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFollowingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingURL: %w", err)
	}
	return oldValue.FollowingURL, nil
}

// ResetFollowingURL resets all changes to the "following_url" field.
func (m *UserMutation) ResetFollowingURL() {
	m.following_url = nil
}

// SetGistsURL sets the "gists_url" field.
func (m *UserMutation) SetGistsURL(s string) {
	m.gists_url = &s
}

// GistsURL returns the value of the "gists_url" field in the mutation.
func (m *UserMutation) GistsURL() (r string, exists bool) {
	v := m.gists_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGistsURL returns the old "gists_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGistsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGistsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGistsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGistsURL: %w", err)
	}
	return oldValue.GistsURL, nil
}

// ResetGistsURL resets all changes to the "gists_url" field.
func (m *UserMutation) ResetGistsURL() {
	m.gists_url = nil
}

// SetStarredURL sets the "starred_url" field.
func (m *UserMutation) SetStarredURL(s string) {
	m.starred_url = &s
}

// StarredURL returns the value of the "starred_url" field in the mutation.
func (m *UserMutation) StarredURL() (r string, exists bool) {
	v := m.starred_url
	if v == nil {
		return
	}
	return *v, true
}

// OldStarredURL returns the old "starred_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStarredURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarredURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarredURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarredURL: %w", err)
	}
	return oldValue.StarredURL, nil
}

// ResetStarredURL resets all changes to the "starred_url" field.
func (m *UserMutation) ResetStarredURL() {
	m.starred_url = nil
}

// SetSubscriptionsURL sets the "subscriptions_url" field.
func (m *UserMutation) SetSubscriptionsURL(s string) {
	m.subscriptions_url = &s
}

// SubscriptionsURL returns the value of the "subscriptions_url" field in the mutation.
func (m *UserMutation) SubscriptionsURL() (r string, exists bool) {
	v := m.subscriptions_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionsURL returns the old "subscriptions_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSubscriptionsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionsURL: %w", err)
	}
	return oldValue.SubscriptionsURL, nil
}

// ResetSubscriptionsURL resets all changes to the "subscriptions_url" field.
func (m *UserMutation) ResetSubscriptionsURL() {
	m.subscriptions_url = nil
}

// SetOrganizationsURL sets the "organizations_url" field.
func (m *UserMutation) SetOrganizationsURL(s string) {
	m.organizations_url = &s
}

// OrganizationsURL returns the value of the "organizations_url" field in the mutation.
func (m *UserMutation) OrganizationsURL() (r string, exists bool) {
	v := m.organizations_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationsURL returns the old "organizations_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganizationsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationsURL: %w", err)
	}
	return oldValue.OrganizationsURL, nil
}

// ResetOrganizationsURL resets all changes to the "organizations_url" field.
func (m *UserMutation) ResetOrganizationsURL() {
	m.organizations_url = nil
}

// SetReposURL sets the "repos_url" field.
func (m *UserMutation) SetReposURL(s string) {
	m.repos_url = &s
}

// ReposURL returns the value of the "repos_url" field in the mutation.
func (m *UserMutation) ReposURL() (r string, exists bool) {
	v := m.repos_url
	if v == nil {
		return
	}
	return *v, true
}

// OldReposURL returns the old "repos_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldReposURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReposURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReposURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReposURL: %w", err)
	}
	return oldValue.ReposURL, nil
}

// ResetReposURL resets all changes to the "repos_url" field.
func (m *UserMutation) ResetReposURL() {
	m.repos_url = nil
}

// SetEventsURL sets the "events_url" field.
func (m *UserMutation) SetEventsURL(s string) {
	m.events_url = &s
}

// EventsURL returns the value of the "events_url" field in the mutation.
func (m *UserMutation) EventsURL() (r string, exists bool) {
	v := m.events_url
	if v == nil {
		return
	}
	return *v, true
}

// OldEventsURL returns the old "events_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEventsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventsURL: %w", err)
	}
	return oldValue.EventsURL, nil
}

// ResetEventsURL resets all changes to the "events_url" field.
func (m *UserMutation) ResetEventsURL() {
	m.events_url = nil
}

// SetReceivedEventsURL sets the "received_events_url" field.
func (m *UserMutation) SetReceivedEventsURL(s string) {
	m.received_events_url = &s
}

// ReceivedEventsURL returns the value of the "received_events_url" field in the mutation.
func (m *UserMutation) ReceivedEventsURL() (r string, exists bool) {
	v := m.received_events_url
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedEventsURL returns the old "received_events_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldReceivedEventsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedEventsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedEventsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedEventsURL: %w", err)
	}
	return oldValue.ReceivedEventsURL, nil
}

// ResetReceivedEventsURL resets all changes to the "received_events_url" field.
func (m *UserMutation) ResetReceivedEventsURL() {
	m.received_events_url = nil
}

// SetType sets the "type" field.
func (m *UserMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserMutation) ResetType() {
	m._type = nil
}

// SetSiteAdmin sets the "site_admin" field.
func (m *UserMutation) SetSiteAdmin(b bool) {
	m.site_admin = &b
}

// SiteAdmin returns the value of the "site_admin" field in the mutation.
func (m *UserMutation) SiteAdmin() (r bool, exists bool) {
	v := m.site_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteAdmin returns the old "site_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSiteAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteAdmin: %w", err)
	}
	return oldValue.SiteAdmin, nil
}

// ResetSiteAdmin resets all changes to the "site_admin" field.
func (m *UserMutation) ResetSiteAdmin() {
	m.site_admin = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetCompany sets the "company" field.
func (m *UserMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *UserMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *UserMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[user.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *UserMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[user.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, user.FieldCompany)
}

// SetBlog sets the "blog" field.
func (m *UserMutation) SetBlog(s string) {
	m.blog = &s
}

// Blog returns the value of the "blog" field in the mutation.
func (m *UserMutation) Blog() (r string, exists bool) {
	v := m.blog
	if v == nil {
		return
	}
	return *v, true
}

// OldBlog returns the old "blog" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBlog(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlog is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlog requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlog: %w", err)
	}
	return oldValue.Blog, nil
}

// ClearBlog clears the value of the "blog" field.
func (m *UserMutation) ClearBlog() {
	m.blog = nil
	m.clearedFields[user.FieldBlog] = struct{}{}
}

// BlogCleared returns if the "blog" field was cleared in this mutation.
func (m *UserMutation) BlogCleared() bool {
	_, ok := m.clearedFields[user.FieldBlog]
	return ok
}

// ResetBlog resets all changes to the "blog" field.
func (m *UserMutation) ResetBlog() {
	m.blog = nil
	delete(m.clearedFields, user.FieldBlog)
}

// SetLocation sets the "location" field.
func (m *UserMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *UserMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[user.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *UserMutation) LocationCleared() bool {
	_, ok := m.clearedFields[user.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *UserMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, user.FieldLocation)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetHireable sets the "hireable" field.
func (m *UserMutation) SetHireable(b bool) {
	m.hireable = &b
}

// Hireable returns the value of the "hireable" field in the mutation.
func (m *UserMutation) Hireable() (r bool, exists bool) {
	v := m.hireable
	if v == nil {
		return
	}
	return *v, true
}

// OldHireable returns the old "hireable" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHireable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHireable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHireable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHireable: %w", err)
	}
	return oldValue.Hireable, nil
}

// ClearHireable clears the value of the "hireable" field.
func (m *UserMutation) ClearHireable() {
	m.hireable = nil
	m.clearedFields[user.FieldHireable] = struct{}{}
}

// HireableCleared returns if the "hireable" field was cleared in this mutation.
func (m *UserMutation) HireableCleared() bool {
	_, ok := m.clearedFields[user.FieldHireable]
	return ok
}

// ResetHireable resets all changes to the "hireable" field.
func (m *UserMutation) ResetHireable() {
	m.hireable = nil
	delete(m.clearedFields, user.FieldHireable)
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetPublicRepos sets the "public_repos" field.
func (m *UserMutation) SetPublicRepos(i int64) {
	m.public_repos = &i
	m.addpublic_repos = nil
}

// PublicRepos returns the value of the "public_repos" field in the mutation.
func (m *UserMutation) PublicRepos() (r int64, exists bool) {
	v := m.public_repos
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicRepos returns the old "public_repos" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPublicRepos(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicRepos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicRepos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicRepos: %w", err)
	}
	return oldValue.PublicRepos, nil
}

// AddPublicRepos adds i to the "public_repos" field.
func (m *UserMutation) AddPublicRepos(i int64) {
	if m.addpublic_repos != nil {
		*m.addpublic_repos += i
	} else {
		m.addpublic_repos = &i
	}
}

// AddedPublicRepos returns the value that was added to the "public_repos" field in this mutation.
func (m *UserMutation) AddedPublicRepos() (r int64, exists bool) {
	v := m.addpublic_repos
	if v == nil {
		return
	}
	return *v, true
}

// ResetPublicRepos resets all changes to the "public_repos" field.
func (m *UserMutation) ResetPublicRepos() {
	m.public_repos = nil
	m.addpublic_repos = nil
}

// SetPublicGists sets the "public_gists" field.
func (m *UserMutation) SetPublicGists(i int64) {
	m.public_gists = &i
	m.addpublic_gists = nil
}

// PublicGists returns the value of the "public_gists" field in the mutation.
func (m *UserMutation) PublicGists() (r int64, exists bool) {
	v := m.public_gists
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicGists returns the old "public_gists" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPublicGists(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicGists is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicGists requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicGists: %w", err)
	}
	return oldValue.PublicGists, nil
}

// AddPublicGists adds i to the "public_gists" field.
func (m *UserMutation) AddPublicGists(i int64) {
	if m.addpublic_gists != nil {
		*m.addpublic_gists += i
	} else {
		m.addpublic_gists = &i
	}
}

// AddedPublicGists returns the value that was added to the "public_gists" field in this mutation.
func (m *UserMutation) AddedPublicGists() (r int64, exists bool) {
	v := m.addpublic_gists
	if v == nil {
		return
	}
	return *v, true
}

// ResetPublicGists resets all changes to the "public_gists" field.
func (m *UserMutation) ResetPublicGists() {
	m.public_gists = nil
	m.addpublic_gists = nil
}

// SetFollowers sets the "followers" field.
func (m *UserMutation) SetFollowers(i int64) {
	m.followers = &i
	m.addfollowers = nil
}

// Followers returns the value of the "followers" field in the mutation.
func (m *UserMutation) Followers() (r int64, exists bool) {
	v := m.followers
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowers returns the old "followers" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFollowers(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowers: %w", err)
	}
	return oldValue.Followers, nil
}

// AddFollowers adds i to the "followers" field.
func (m *UserMutation) AddFollowers(i int64) {
	if m.addfollowers != nil {
		*m.addfollowers += i
	} else {
		m.addfollowers = &i
	}
}

// AddedFollowers returns the value that was added to the "followers" field in this mutation.
func (m *UserMutation) AddedFollowers() (r int64, exists bool) {
	v := m.addfollowers
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowers resets all changes to the "followers" field.
func (m *UserMutation) ResetFollowers() {
	m.followers = nil
	m.addfollowers = nil
}

// SetFollowing sets the "following" field.
func (m *UserMutation) SetFollowing(i int64) {
	m.following = &i
	m.addfollowing = nil
}

// Following returns the value of the "following" field in the mutation.
func (m *UserMutation) Following() (r int64, exists bool) {
	v := m.following
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowing returns the old "following" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFollowing(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowing: %w", err)
	}
	return oldValue.Following, nil
}

// AddFollowing adds i to the "following" field.
func (m *UserMutation) AddFollowing(i int64) {
	if m.addfollowing != nil {
		*m.addfollowing += i
	} else {
		m.addfollowing = &i
	}
}

// AddedFollowing returns the value that was added to the "following" field in this mutation.
func (m *UserMutation) AddedFollowing() (r int64, exists bool) {
	v := m.addfollowing
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowing resets all changes to the "following" field.
func (m *UserMutation) ResetFollowing() {
	m.following = nil
	m.addfollowing = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddRepositoryIDs adds the "repositories" edge to the Repository entity by ids.
func (m *UserMutation) AddRepositoryIDs(ids ...int64) {
	if m.repositories == nil {
		m.repositories = make(map[int64]struct{})
	}
	for i := range ids {
		m.repositories[ids[i]] = struct{}{}
	}
}

// ClearRepositories clears the "repositories" edge to the Repository entity.
func (m *UserMutation) ClearRepositories() {
	m.clearedrepositories = true
}

// RepositoriesCleared reports if the "repositories" edge to the Repository entity was cleared.
func (m *UserMutation) RepositoriesCleared() bool {
	return m.clearedrepositories
}

// RemoveRepositoryIDs removes the "repositories" edge to the Repository entity by IDs.
func (m *UserMutation) RemoveRepositoryIDs(ids ...int64) {
	if m.removedrepositories == nil {
		m.removedrepositories = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.repositories, ids[i])
		m.removedrepositories[ids[i]] = struct{}{}
	}
}

// RemovedRepositories returns the removed IDs of the "repositories" edge to the Repository entity.
func (m *UserMutation) RemovedRepositoriesIDs() (ids []int64) {
	for id := range m.removedrepositories {
		ids = append(ids, id)
	}
	return
}

// RepositoriesIDs returns the "repositories" edge IDs in the mutation.
func (m *UserMutation) RepositoriesIDs() (ids []int64) {
	for id := range m.repositories {
		ids = append(ids, id)
	}
	return
}

// ResetRepositories resets all changes to the "repositories" edge.
func (m *UserMutation) ResetRepositories() {
	m.repositories = nil
	m.clearedrepositories = false
	m.removedrepositories = nil
}

// AddIssuesCreatedIDs adds the "issues_created" edge to the Issue entity by ids.
func (m *UserMutation) AddIssuesCreatedIDs(ids ...int64) {
	if m.issues_created == nil {
		m.issues_created = make(map[int64]struct{})
	}
	for i := range ids {
		m.issues_created[ids[i]] = struct{}{}
	}
}

// ClearIssuesCreated clears the "issues_created" edge to the Issue entity.
func (m *UserMutation) ClearIssuesCreated() {
	m.clearedissues_created = true
}

// IssuesCreatedCleared reports if the "issues_created" edge to the Issue entity was cleared.
func (m *UserMutation) IssuesCreatedCleared() bool {
	return m.clearedissues_created
}

// RemoveIssuesCreatedIDs removes the "issues_created" edge to the Issue entity by IDs.
func (m *UserMutation) RemoveIssuesCreatedIDs(ids ...int64) {
	if m.removedissues_created == nil {
		m.removedissues_created = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.issues_created, ids[i])
		m.removedissues_created[ids[i]] = struct{}{}
	}
}

// RemovedIssuesCreated returns the removed IDs of the "issues_created" edge to the Issue entity.
func (m *UserMutation) RemovedIssuesCreatedIDs() (ids []int64) {
	for id := range m.removedissues_created {
		ids = append(ids, id)
	}
	return
}

// IssuesCreatedIDs returns the "issues_created" edge IDs in the mutation.
func (m *UserMutation) IssuesCreatedIDs() (ids []int64) {
	for id := range m.issues_created {
		ids = append(ids, id)
	}
	return
}

// ResetIssuesCreated resets all changes to the "issues_created" edge.
func (m *UserMutation) ResetIssuesCreated() {
	m.issues_created = nil
	m.clearedissues_created = false
	m.removedissues_created = nil
}

// AddCommentsCreatedIDs adds the "comments_created" edge to the IssueComment entity by ids.
func (m *UserMutation) AddCommentsCreatedIDs(ids ...int64) {
	if m.comments_created == nil {
		m.comments_created = make(map[int64]struct{})
	}
	for i := range ids {
		m.comments_created[ids[i]] = struct{}{}
	}
}

// ClearCommentsCreated clears the "comments_created" edge to the IssueComment entity.
func (m *UserMutation) ClearCommentsCreated() {
	m.clearedcomments_created = true
}

// CommentsCreatedCleared reports if the "comments_created" edge to the IssueComment entity was cleared.
func (m *UserMutation) CommentsCreatedCleared() bool {
	return m.clearedcomments_created
}

// RemoveCommentsCreatedIDs removes the "comments_created" edge to the IssueComment entity by IDs.
func (m *UserMutation) RemoveCommentsCreatedIDs(ids ...int64) {
	if m.removedcomments_created == nil {
		m.removedcomments_created = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.comments_created, ids[i])
		m.removedcomments_created[ids[i]] = struct{}{}
	}
}

// RemovedCommentsCreated returns the removed IDs of the "comments_created" edge to the IssueComment entity.
func (m *UserMutation) RemovedCommentsCreatedIDs() (ids []int64) {
	for id := range m.removedcomments_created {
		ids = append(ids, id)
	}
	return
}

// CommentsCreatedIDs returns the "comments_created" edge IDs in the mutation.
func (m *UserMutation) CommentsCreatedIDs() (ids []int64) {
	for id := range m.comments_created {
		ids = append(ids, id)
	}
	return
}

// ResetCommentsCreated resets all changes to the "comments_created" edge.
func (m *UserMutation) ResetCommentsCreated() {
	m.comments_created = nil
	m.clearedcomments_created = false
	m.removedcomments_created = nil
}

// AddIssuesAssignedIDs adds the "issues_assigned" edge to the Issue entity by ids.
func (m *UserMutation) AddIssuesAssignedIDs(ids ...int64) {
	if m.issues_assigned == nil {
		m.issues_assigned = make(map[int64]struct{})
	}
	for i := range ids {
		m.issues_assigned[ids[i]] = struct{}{}
	}
}

// ClearIssuesAssigned clears the "issues_assigned" edge to the Issue entity.
func (m *UserMutation) ClearIssuesAssigned() {
	m.clearedissues_assigned = true
}

// IssuesAssignedCleared reports if the "issues_assigned" edge to the Issue entity was cleared.
func (m *UserMutation) IssuesAssignedCleared() bool {
	return m.clearedissues_assigned
}

// RemoveIssuesAssignedIDs removes the "issues_assigned" edge to the Issue entity by IDs.
func (m *UserMutation) RemoveIssuesAssignedIDs(ids ...int64) {
	if m.removedissues_assigned == nil {
		m.removedissues_assigned = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.issues_assigned, ids[i])
		m.removedissues_assigned[ids[i]] = struct{}{}
	}
}

// RemovedIssuesAssigned returns the removed IDs of the "issues_assigned" edge to the Issue entity.
func (m *UserMutation) RemovedIssuesAssignedIDs() (ids []int64) {
	for id := range m.removedissues_assigned {
		ids = append(ids, id)
	}
	return
}

// IssuesAssignedIDs returns the "issues_assigned" edge IDs in the mutation.
func (m *UserMutation) IssuesAssignedIDs() (ids []int64) {
	for id := range m.issues_assigned {
		ids = append(ids, id)
	}
	return
}

// ResetIssuesAssigned resets all changes to the "issues_assigned" edge.
func (m *UserMutation) ResetIssuesAssigned() {
	m.issues_assigned = nil
	m.clearedissues_assigned = false
	m.removedissues_assigned = nil
}

// AddIssuesClosedIDs adds the "issues_closed" edge to the Issue entity by ids.
func (m *UserMutation) AddIssuesClosedIDs(ids ...int64) {
	if m.issues_closed == nil {
		m.issues_closed = make(map[int64]struct{})
	}
	for i := range ids {
		m.issues_closed[ids[i]] = struct{}{}
	}
}

// ClearIssuesClosed clears the "issues_closed" edge to the Issue entity.
func (m *UserMutation) ClearIssuesClosed() {
	m.clearedissues_closed = true
}

// IssuesClosedCleared reports if the "issues_closed" edge to the Issue entity was cleared.
func (m *UserMutation) IssuesClosedCleared() bool {
	return m.clearedissues_closed
}

// RemoveIssuesClosedIDs removes the "issues_closed" edge to the Issue entity by IDs.
func (m *UserMutation) RemoveIssuesClosedIDs(ids ...int64) {
	if m.removedissues_closed == nil {
		m.removedissues_closed = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.issues_closed, ids[i])
		m.removedissues_closed[ids[i]] = struct{}{}
	}
}

// RemovedIssuesClosed returns the removed IDs of the "issues_closed" edge to the Issue entity.
func (m *UserMutation) RemovedIssuesClosedIDs() (ids []int64) {
	for id := range m.removedissues_closed {
		ids = append(ids, id)
	}
	return
}

// IssuesClosedIDs returns the "issues_closed" edge IDs in the mutation.
func (m *UserMutation) IssuesClosedIDs() (ids []int64) {
	for id := range m.issues_closed {
		ids = append(ids, id)
	}
	return
}

// ResetIssuesClosed resets all changes to the "issues_closed" edge.
func (m *UserMutation) ResetIssuesClosed() {
	m.issues_closed = nil
	m.clearedissues_closed = false
	m.removedissues_closed = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.login != nil {
		fields = append(fields, user.FieldLogin)
	}
	if m.node_id != nil {
		fields = append(fields, user.FieldNodeID)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.gravatar_id != nil {
		fields = append(fields, user.FieldGravatarID)
	}
	if m.url != nil {
		fields = append(fields, user.FieldURL)
	}
	if m.html_url != nil {
		fields = append(fields, user.FieldHTMLURL)
	}
	if m.followers_url != nil {
		fields = append(fields, user.FieldFollowersURL)
	}
	if m.following_url != nil {
		fields = append(fields, user.FieldFollowingURL)
	}
	if m.gists_url != nil {
		fields = append(fields, user.FieldGistsURL)
	}
	if m.starred_url != nil {
		fields = append(fields, user.FieldStarredURL)
	}
	if m.subscriptions_url != nil {
		fields = append(fields, user.FieldSubscriptionsURL)
	}
	if m.organizations_url != nil {
		fields = append(fields, user.FieldOrganizationsURL)
	}
	if m.repos_url != nil {
		fields = append(fields, user.FieldReposURL)
	}
	if m.events_url != nil {
		fields = append(fields, user.FieldEventsURL)
	}
	if m.received_events_url != nil {
		fields = append(fields, user.FieldReceivedEventsURL)
	}
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.site_admin != nil {
		fields = append(fields, user.FieldSiteAdmin)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.company != nil {
		fields = append(fields, user.FieldCompany)
	}
	if m.blog != nil {
		fields = append(fields, user.FieldBlog)
	}
	if m.location != nil {
		fields = append(fields, user.FieldLocation)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.hireable != nil {
		fields = append(fields, user.FieldHireable)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.public_repos != nil {
		fields = append(fields, user.FieldPublicRepos)
	}
	if m.public_gists != nil {
		fields = append(fields, user.FieldPublicGists)
	}
	if m.followers != nil {
		fields = append(fields, user.FieldFollowers)
	}
	if m.following != nil {
		fields = append(fields, user.FieldFollowing)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldLogin:
		return m.Login()
	case user.FieldNodeID:
		return m.NodeID()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldGravatarID:
		return m.GravatarID()
	case user.FieldURL:
		return m.URL()
	case user.FieldHTMLURL:
		return m.HTMLURL()
	case user.FieldFollowersURL:
		return m.FollowersURL()
	case user.FieldFollowingURL:
		return m.FollowingURL()
	case user.FieldGistsURL:
		return m.GistsURL()
	case user.FieldStarredURL:
		return m.StarredURL()
	case user.FieldSubscriptionsURL:
		return m.SubscriptionsURL()
	case user.FieldOrganizationsURL:
		return m.OrganizationsURL()
	case user.FieldReposURL:
		return m.ReposURL()
	case user.FieldEventsURL:
		return m.EventsURL()
	case user.FieldReceivedEventsURL:
		return m.ReceivedEventsURL()
	case user.FieldType:
		return m.GetType()
	case user.FieldSiteAdmin:
		return m.SiteAdmin()
	case user.FieldName:
		return m.Name()
	case user.FieldCompany:
		return m.Company()
	case user.FieldBlog:
		return m.Blog()
	case user.FieldLocation:
		return m.Location()
	case user.FieldEmail:
		return m.Email()
	case user.FieldHireable:
		return m.Hireable()
	case user.FieldBio:
		return m.Bio()
	case user.FieldPublicRepos:
		return m.PublicRepos()
	case user.FieldPublicGists:
		return m.PublicGists()
	case user.FieldFollowers:
		return m.Followers()
	case user.FieldFollowing:
		return m.Following()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldLogin:
		return m.OldLogin(ctx)
	case user.FieldNodeID:
		return m.OldNodeID(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldGravatarID:
		return m.OldGravatarID(ctx)
	case user.FieldURL:
		return m.OldURL(ctx)
	case user.FieldHTMLURL:
		return m.OldHTMLURL(ctx)
	case user.FieldFollowersURL:
		return m.OldFollowersURL(ctx)
	case user.FieldFollowingURL:
		return m.OldFollowingURL(ctx)
	case user.FieldGistsURL:
		return m.OldGistsURL(ctx)
	case user.FieldStarredURL:
		return m.OldStarredURL(ctx)
	case user.FieldSubscriptionsURL:
		return m.OldSubscriptionsURL(ctx)
	case user.FieldOrganizationsURL:
		return m.OldOrganizationsURL(ctx)
	case user.FieldReposURL:
		return m.OldReposURL(ctx)
	case user.FieldEventsURL:
		return m.OldEventsURL(ctx)
	case user.FieldReceivedEventsURL:
		return m.OldReceivedEventsURL(ctx)
	case user.FieldType:
		return m.OldType(ctx)
	case user.FieldSiteAdmin:
		return m.OldSiteAdmin(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldCompany:
		return m.OldCompany(ctx)
	case user.FieldBlog:
		return m.OldBlog(ctx)
	case user.FieldLocation:
		return m.OldLocation(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldHireable:
		return m.OldHireable(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldPublicRepos:
		return m.OldPublicRepos(ctx)
	case user.FieldPublicGists:
		return m.OldPublicGists(ctx)
	case user.FieldFollowers:
		return m.OldFollowers(ctx)
	case user.FieldFollowing:
		return m.OldFollowing(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogin(v)
		return nil
	case user.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldGravatarID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGravatarID(v)
		return nil
	case user.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case user.FieldHTMLURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLURL(v)
		return nil
	case user.FieldFollowersURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowersURL(v)
		return nil
	case user.FieldFollowingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingURL(v)
		return nil
	case user.FieldGistsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGistsURL(v)
		return nil
	case user.FieldStarredURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarredURL(v)
		return nil
	case user.FieldSubscriptionsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionsURL(v)
		return nil
	case user.FieldOrganizationsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationsURL(v)
		return nil
	case user.FieldReposURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReposURL(v)
		return nil
	case user.FieldEventsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventsURL(v)
		return nil
	case user.FieldReceivedEventsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedEventsURL(v)
		return nil
	case user.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user.FieldSiteAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteAdmin(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case user.FieldBlog:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlog(v)
		return nil
	case user.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldHireable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHireable(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldPublicRepos:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicRepos(v)
		return nil
	case user.FieldPublicGists:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicGists(v)
		return nil
	case user.FieldFollowers:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowers(v)
		return nil
	case user.FieldFollowing:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowing(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addpublic_repos != nil {
		fields = append(fields, user.FieldPublicRepos)
	}
	if m.addpublic_gists != nil {
		fields = append(fields, user.FieldPublicGists)
	}
	if m.addfollowers != nil {
		fields = append(fields, user.FieldFollowers)
	}
	if m.addfollowing != nil {
		fields = append(fields, user.FieldFollowing)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPublicRepos:
		return m.AddedPublicRepos()
	case user.FieldPublicGists:
		return m.AddedPublicGists()
	case user.FieldFollowers:
		return m.AddedFollowers()
	case user.FieldFollowing:
		return m.AddedFollowing()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldPublicRepos:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicRepos(v)
		return nil
	case user.FieldPublicGists:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicGists(v)
		return nil
	case user.FieldFollowers:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowers(v)
		return nil
	case user.FieldFollowing:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowing(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldGravatarID) {
		fields = append(fields, user.FieldGravatarID)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldCompany) {
		fields = append(fields, user.FieldCompany)
	}
	if m.FieldCleared(user.FieldBlog) {
		fields = append(fields, user.FieldBlog)
	}
	if m.FieldCleared(user.FieldLocation) {
		fields = append(fields, user.FieldLocation)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldHireable) {
		fields = append(fields, user.FieldHireable)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldGravatarID:
		m.ClearGravatarID()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldCompany:
		m.ClearCompany()
		return nil
	case user.FieldBlog:
		m.ClearBlog()
		return nil
	case user.FieldLocation:
		m.ClearLocation()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldHireable:
		m.ClearHireable()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldLogin:
		m.ResetLogin()
		return nil
	case user.FieldNodeID:
		m.ResetNodeID()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldGravatarID:
		m.ResetGravatarID()
		return nil
	case user.FieldURL:
		m.ResetURL()
		return nil
	case user.FieldHTMLURL:
		m.ResetHTMLURL()
		return nil
	case user.FieldFollowersURL:
		m.ResetFollowersURL()
		return nil
	case user.FieldFollowingURL:
		m.ResetFollowingURL()
		return nil
	case user.FieldGistsURL:
		m.ResetGistsURL()
		return nil
	case user.FieldStarredURL:
		m.ResetStarredURL()
		return nil
	case user.FieldSubscriptionsURL:
		m.ResetSubscriptionsURL()
		return nil
	case user.FieldOrganizationsURL:
		m.ResetOrganizationsURL()
		return nil
	case user.FieldReposURL:
		m.ResetReposURL()
		return nil
	case user.FieldEventsURL:
		m.ResetEventsURL()
		return nil
	case user.FieldReceivedEventsURL:
		m.ResetReceivedEventsURL()
		return nil
	case user.FieldType:
		m.ResetType()
		return nil
	case user.FieldSiteAdmin:
		m.ResetSiteAdmin()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldCompany:
		m.ResetCompany()
		return nil
	case user.FieldBlog:
		m.ResetBlog()
		return nil
	case user.FieldLocation:
		m.ResetLocation()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldHireable:
		m.ResetHireable()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldPublicRepos:
		m.ResetPublicRepos()
		return nil
	case user.FieldPublicGists:
		m.ResetPublicGists()
		return nil
	case user.FieldFollowers:
		m.ResetFollowers()
		return nil
	case user.FieldFollowing:
		m.ResetFollowing()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.repositories != nil {
		edges = append(edges, user.EdgeRepositories)
	}
	if m.issues_created != nil {
		edges = append(edges, user.EdgeIssuesCreated)
	}
	if m.comments_created != nil {
		edges = append(edges, user.EdgeCommentsCreated)
	}
	if m.issues_assigned != nil {
		edges = append(edges, user.EdgeIssuesAssigned)
	}
	if m.issues_closed != nil {
		edges = append(edges, user.EdgeIssuesClosed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.repositories))
		for id := range m.repositories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIssuesCreated:
		ids := make([]ent.Value, 0, len(m.issues_created))
		for id := range m.issues_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCommentsCreated:
		ids := make([]ent.Value, 0, len(m.comments_created))
		for id := range m.comments_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIssuesAssigned:
		ids := make([]ent.Value, 0, len(m.issues_assigned))
		for id := range m.issues_assigned {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIssuesClosed:
		ids := make([]ent.Value, 0, len(m.issues_closed))
		for id := range m.issues_closed {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrepositories != nil {
		edges = append(edges, user.EdgeRepositories)
	}
	if m.removedissues_created != nil {
		edges = append(edges, user.EdgeIssuesCreated)
	}
	if m.removedcomments_created != nil {
		edges = append(edges, user.EdgeCommentsCreated)
	}
	if m.removedissues_assigned != nil {
		edges = append(edges, user.EdgeIssuesAssigned)
	}
	if m.removedissues_closed != nil {
		edges = append(edges, user.EdgeIssuesClosed)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.removedrepositories))
		for id := range m.removedrepositories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIssuesCreated:
		ids := make([]ent.Value, 0, len(m.removedissues_created))
		for id := range m.removedissues_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCommentsCreated:
		ids := make([]ent.Value, 0, len(m.removedcomments_created))
		for id := range m.removedcomments_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIssuesAssigned:
		ids := make([]ent.Value, 0, len(m.removedissues_assigned))
		for id := range m.removedissues_assigned {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIssuesClosed:
		ids := make([]ent.Value, 0, len(m.removedissues_closed))
		for id := range m.removedissues_closed {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrepositories {
		edges = append(edges, user.EdgeRepositories)
	}
	if m.clearedissues_created {
		edges = append(edges, user.EdgeIssuesCreated)
	}
	if m.clearedcomments_created {
		edges = append(edges, user.EdgeCommentsCreated)
	}
	if m.clearedissues_assigned {
		edges = append(edges, user.EdgeIssuesAssigned)
	}
	if m.clearedissues_closed {
		edges = append(edges, user.EdgeIssuesClosed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRepositories:
		return m.clearedrepositories
	case user.EdgeIssuesCreated:
		return m.clearedissues_created
	case user.EdgeCommentsCreated:
		return m.clearedcomments_created
	case user.EdgeIssuesAssigned:
		return m.clearedissues_assigned
	case user.EdgeIssuesClosed:
		return m.clearedissues_closed
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRepositories:
		m.ResetRepositories()
		return nil
	case user.EdgeIssuesCreated:
		m.ResetIssuesCreated()
		return nil
	case user.EdgeCommentsCreated:
		m.ResetCommentsCreated()
		return nil
	case user.EdgeIssuesAssigned:
		m.ResetIssuesAssigned()
		return nil
	case user.EdgeIssuesClosed:
		m.ResetIssuesClosed()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
